{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Taurus Data Model Documentation This is the next major data model developed by Citrine, codename taurus . The model links together materials, the processes that produced them, and the measurements that characterize them. This facilitates the backwards traversal from a measurement to the material on which it was performed to the process by which it was produced to the materials which were used in that process. It generalizes and matures preparation and subSystems objects within the PIF ( Physical Information File ). Additionally, the model makes a first-class distinction between intent and realization , captured by Spec and Run objects, respectively. A single intent Spec can be realized into multiple Run objects. This generalizes and matures the ideal concept from the PIF's Composition and Quantity objects. The model contains a new type of object: the Measurement Run . Measurements capture discrete measurement activity, including the parameters and conditions associated with a set of measured properties. This many-to-many relationship between properties, conditions, and parameters resolves a fundamental ambiguity present in the PIF; which properties were measured at the same time under the same conditions? Specification of the NextGen Data format # The format is described in the following subsections: Value Types Attributes Attribute Templates Object Templates Objects Unique Identifiers Tags File Links Getting help # Check out our FAQ !","title":"Taurus Data Model Documentation"},{"location":"#specification-of-the-nextgen-data-format","text":"The format is described in the following subsections: Value Types Attributes Attribute Templates Object Templates Objects Unique Identifiers Tags File Links","title":"Specification of the NextGen Data format"},{"location":"#getting-help","text":"Check out our FAQ !","title":"Getting help"},{"location":"faq/","text":"FAQ It's not you; it's us. Taurus is not a simple representation, and we frequently get questions about how to use it to represent certain kinds of data. This page attempts to answer some of those questions. Where do I store statistics about my measurements # Let's say that you have data for the same kind of measurement being repeated multiple times. For example, you take a sample from your material, subdivide it 8 times, and perform the same measurement on each of those 8 sub-samples. The measurement that you are performing can be represented by a single MeasurementSpec and each of those 8 sub-samples as its own MeasurementRun associated with that spec. Each MeasurementRun is associated with the MatererialRun representing the material that you sampled and sub-divided. For each property in the MeasurementRun objects, you may want to compute some statistics of the 8-sample distribution. For example: the mean and the standard deviation of each property and/or its minimum and maximum values. In the future, these statistics will be automatically computed on the Citrine platform. For now, you can compute them yourself and record them in another MeasurementRun object distinct from the 8 samples. If there are multiple properties and/or multiple statistics, they should all go in the same MeasurementRun . The statistics should be Property attributes with their origin field set to computed . How do I represent repeated applications of the same process? # Consider a situation in which a process is repeatedly applied to a material, but does not substantially change the material. For example, repeated application of heat-treatment to harden a ceramic or multiple coats of paint. Because material histories are chronological, each application must be a new process and must produce a new output material. The materials/processes may reference the same templates, however, if the same attributes are relevant for each iteration. How do I represent repeated uses of the same material? # It is perfectly fine for the same material to be used in multiple processes throughout a material history, but a new ingredient must be created for each use. Ingredients annotate the use of a specific material in a specific process, recording how much was used and labeling the role of the material. Process templates should be used to describe what types of ingredients are expected in a process. The same material can even be used multiple times in one process. Consider the following example: a thin film is created by thermally evaporating three materials in succession onto a substrate. The thermal evaporation process template specifies the allowed names as \"layer 1,\" \"layer 2,\" and \"layer 3.\" We have several materials to choose from for the three layers, but in one instance we wish to evaporate a layer of material \"A,\" then a layer of \"B,\" then a final layer of \"A.\" We create a process spec linked to the thermal evaporation process template and create three ingredient specs, each of which point to the process spec as their process . One ingredient points to \"A\" as its material and has layer 1 as its name. One points to \"B\" as its material and has layer 2 as its name. And the final ingredient spec also points to \"A\" as its material but is differentiated because it has layer 3 as its name. What is the difference between description and notes ? # description is a field on both Attribute Templates and Object Templates . It is used to describe the type of data that a template is intended to constrain - the documentation of its intended use. We strongly encourage documenting all templates, given both how important they are in constraining data and communicating structure to analysis algorithms, and that a template is likely to be reused by multiple users. notes are associated with Attributes and Objects . This is a place to put pieces of information that may be important to understanding this particular piece of data but do not naturally fit in the other fields. This might include an annotation about something unusual about this particular sample. Notes normally contain information that is useful for a human but would not be useful in training a machine learning model.","title":"FAQ"},{"location":"faq/#where-do-i-store-statistics-about-my-measurements","text":"Let's say that you have data for the same kind of measurement being repeated multiple times. For example, you take a sample from your material, subdivide it 8 times, and perform the same measurement on each of those 8 sub-samples. The measurement that you are performing can be represented by a single MeasurementSpec and each of those 8 sub-samples as its own MeasurementRun associated with that spec. Each MeasurementRun is associated with the MatererialRun representing the material that you sampled and sub-divided. For each property in the MeasurementRun objects, you may want to compute some statistics of the 8-sample distribution. For example: the mean and the standard deviation of each property and/or its minimum and maximum values. In the future, these statistics will be automatically computed on the Citrine platform. For now, you can compute them yourself and record them in another MeasurementRun object distinct from the 8 samples. If there are multiple properties and/or multiple statistics, they should all go in the same MeasurementRun . The statistics should be Property attributes with their origin field set to computed .","title":"Where do I store statistics about my measurements"},{"location":"faq/#how-do-i-represent-repeated-applications-of-the-same-process","text":"Consider a situation in which a process is repeatedly applied to a material, but does not substantially change the material. For example, repeated application of heat-treatment to harden a ceramic or multiple coats of paint. Because material histories are chronological, each application must be a new process and must produce a new output material. The materials/processes may reference the same templates, however, if the same attributes are relevant for each iteration.","title":"How do I represent repeated applications of the same process?"},{"location":"faq/#how-do-i-represent-repeated-uses-of-the-same-material","text":"It is perfectly fine for the same material to be used in multiple processes throughout a material history, but a new ingredient must be created for each use. Ingredients annotate the use of a specific material in a specific process, recording how much was used and labeling the role of the material. Process templates should be used to describe what types of ingredients are expected in a process. The same material can even be used multiple times in one process. Consider the following example: a thin film is created by thermally evaporating three materials in succession onto a substrate. The thermal evaporation process template specifies the allowed names as \"layer 1,\" \"layer 2,\" and \"layer 3.\" We have several materials to choose from for the three layers, but in one instance we wish to evaporate a layer of material \"A,\" then a layer of \"B,\" then a final layer of \"A.\" We create a process spec linked to the thermal evaporation process template and create three ingredient specs, each of which point to the process spec as their process . One ingredient points to \"A\" as its material and has layer 1 as its name. One points to \"B\" as its material and has layer 2 as its name. And the final ingredient spec also points to \"A\" as its material but is differentiated because it has layer 3 as its name.","title":"How do I represent repeated uses of the same material?"},{"location":"faq/#what-is-the-difference-between-description-and-notes","text":"description is a field on both Attribute Templates and Object Templates . It is used to describe the type of data that a template is intended to constrain - the documentation of its intended use. We strongly encourage documenting all templates, given both how important they are in constraining data and communicating structure to analysis algorithms, and that a template is likely to be reused by multiple users. notes are associated with Attributes and Objects . This is a place to put pieces of information that may be important to understanding this particular piece of data but do not naturally fit in the other fields. This might include an annotation about something unusual about this particular sample. Notes normally contain information that is useful for a human but would not be useful in training a machine learning model.","title":"What is the difference between description and notes?"},{"location":"high-level-overview/","text":"High Level Overview How is data stored # We have given this format the codename taurus . Taurus stores data via interconnected Data Objects, representing Specs and Runs of Materials, Processing steps, Measurements, and Ingredient information. This format is graphical rather than tabular. It will support a JSON-based serialization, like the PIF , but with links as references rather than nested objects (i.e. subsystems). Conversely, there are many new ideas that exist in taurus that are not captured by the PIF, including: Process history and process order, including the input materials to process steps Conditions that are shared between properties Specified vs actual values Ingredient information of input materials of a process How are Data Objects defined? # There are four categories of Data Objects in Taurus: Materials, Processes, Measurements, and Ingredients. These represent real world objects in the development of materials. The 4 categories of Data Objects can only be linked in specific ways, for example, a Process Object can only be linked to one or many Material Objects as its input, more details are explained in Table1. Each Object can be represented in 3 different states, these states are defined below, they are Template, Spec, and Run. Note, Ingredient Objects cannot be represented in the Template state. Material Object: Describes a material by a name used in an organization and optional notes to describe it. Measurement Object: Describes an operation used to measure or characterize one or more properties of a material and the parameters and conditions for that operations. Process Object: Describes an operation used with the goal of transforming a material. Ingredient Object: Annotates a material with information related to its usage in a process including name (label on the ingredient that is unique within the process that contains it) and labels (additional labels on the ingredient) Object Examples Linked Objects State Possible Attributes Material Glass, H2O n/a Template Properties ^ ^ input: Process (1); Measurement (0 or many) Spec Properties and Conditions ^ ^ ^ Run none Process Gas pressure sintering, Binder burnout n/a Template Parameters and Conditions ^ ^ input: Ingredient (0 or many); output: Material (1) Spec Parameters and Conditions ^ ^ ^ Run Parameters and Conditions Measurement 3 point bend, combustion analysis n/a Template Properties, Parameters, and Conditions ^ ^ Material (1) Spec Parameters, and Conditions ^ ^ ^ Run Properties, Parameters, and Conditions Ingredient 80wt%, 20lbs, solute Material (1) Spec n/a ^ ^ ^ Run n/a Table1: Shows the relation of Objects to other Objects and Attributes possible in each state. How are Attributes defined? # Each Data Object (except Ingredient Objects) can contain Attributes that describe it. There are three different categories of Attributes: Properties, Parameters, and Conditions. Attributes contain structured materials data that is representative of an Data Object. For example, a Process Object can have Parameters and Conditions as such: \u201csinter at 2400 K for 6 hours in kiln 14\u201d. Property Attribute: Describes a property that is measured or calculated, they are aspects of a material, e.g. \u201cthe hardness of the sample\u201d. Parameter Attribute: Describes the settings of a tool that are set by the user for a specific purpose, e.g. \u201cthe size of the indenter\u201d or \u201cthe grid spacing in a simulation\u201d. Condition Attribute: Describes the aspects of the environment during a process or measurement, e.g. \u201cthe temperature of the environment during measurement\u201d. Each Attribute has specified fields that are required or optional as defined in Table3 and Table6 below. How are States defined? # There are 3 main states in which Data Objects exist: Templates, Spec, and Run. Taurus distinguishes between the generalization of what might be done (Template), the intent to do something (Spec), and the actual result of doing it (Run). As an example, one can have a Template for a Process Object defined as \u201csinter at {temperature} for {time} in kiln {id}\u201d. This would be the Template used for a Spec of a kiln process used in the production of alumina. The Spec of the Process object might be \u201csinter at 2400 K for 6 hours in kiln 14\u201d. The Process Run object would be what really happened when the process was conducted. For example, someone may have run the kiln and it ran at 2395 K. The Run of the Process object would be \u201csinter at 2395 K for 5.75 hours in kiln 14\u201d. All Data Objects (and all the Attributes that describe those Data Objects) in any State have specified fields that are required or optional, Table2 goes into further detail about the possible fields in all Data Objects and Attributes. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one Table2: Defines the possible fields in all Data Objects and Attributes in all states Templates # Templates are generalizations of Data Objects used to standardize data in Taurus. Templates are used at write time to validate data and at read time to associate groups of information together. Each Spec and Run Object or Attribute (excluding Ingredient Objects and Metadata Attributes) requires a linked Template to support this read and write time association and validation respectively. Attribute Templates # An Attribute Template specifies the bounds that are acceptable for an Attribute. For example, an Attribute Template could specify a Real value bounded between -3 and +17, or it could define a Categorical bound with the following allowed categories: \"salt\", \"not salt\". The values of an Attribute with an Attribute Template must conform to the bounds specified by the Template. If the value is not compatible with the Template (e.g. if the Template specifies that the value must be in the range [0, 1] but the value is 2), an error is thrown. Table3 below defines the possible fields in all Attributes in the Template state. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one description Optional one bounds Required one Table3 : Shows the fields available for Attributes in the Template state The scope defines to which category of Attribute (Property, Parameter, or Condition) the Attribute Template applies. Object Templates # Object Templates are collections of Attribute Templates that together constrain the values of an Data Object's associated Attributes to valid ranges, and provide a common structure for describing similar Data Objects. Object Templates are useful for validating that all Data Objects being written or generated by a script are consistent and valid. In the future, Object Templates could be used to generate data input forms or similar interfaces. Table4 below defines the possible fields in all Data Objects in the Template state. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one description Optional one Table4 : Shows the fields available for each category of Data Object in the Template state All Object Templates can also have additional Attribute Bounds set on defined Attributes. These are additional bounds that can be applied to Attributes associated with that Data Object. For example, consider there exists a Condition Attribute Template called \"Oven Temperature\" that is defined from 0 to 10,000 Kelvin and a Process Object Template that includes the \"Oven Temperature\" Condition Template. Along with the Condition Template \u201cOven Temperature\u201d, the Process Template can include additional Attribute bounds and restrict the values that can be applied to that Condition between 300 and 600 Kelvin. That second restriction is represented by a second bound paired with the Condition Template in the Process Object Template. Table5 below identifies all the possible Attributes that each Data Object can contain in the Template state. Object Template Property Template Parameter Template Condition Template Material Template yes no no Process Template no yes yes Measurement Template yes yes yes Table5 : Shows which Attributes can be linked to each Data Object in the Template state. Specs and Runs # Specs define the intent to do something, usually formalized in the format of an experiment request, the intention of an experiment, or the definition of a property. For example, the normal boiling point of pure water is 99.61 C, a spec. Runs describe how a material, process, or measurement were actually performed, defined, or evaluated and the end results of that evaluation. For example, a sample of water boiled at 101 C, a run. Attribute in Specs and Runs # Each Attribute has specified fields that are required or optional for both Spec or Run state. Table6 goes into further detail about the possible fields. Table6 represents the Attributes in diagram. Field Required/Optional Quantity Possible name Required one value Required one notes Optional one origin Required one template Optional one file_links Optional many Table6 : Shows the fields available for Attributes in the Spec and Run context. All attributes must specify the origin of their data as one of: Specified: it is the intention to have this value Measured: this was directly measured during the process or measurement run Computed: this was calculated based on other measured or derived properties Predicted: this was calculated based on a model, e.g. machine learning or simulation Summary: this was calculated based on a set of the same property at a finer level of granularity (aggregation of data) Unknown: the origin is not known, typically when migrating legacy data A value is a complex type that may contain both central (i.e. expected) and distributional (i.e. uncertainty) information. It also includes units for real (i.e. continuous) values. Data Object Specs and Runs # Object Specs require an associated Object Template that bounds the valid units and values of the Attributes on the Spec. With the linking of Specs to Runs, Runs inherit associated Templates through Specs. For example, Process Runs associated with a Process Spec inherit the Template associated with the Spec, and their Attributes are thus also constrained by the Template. Many Specs can reference the same Object Template. Each Spec can be associated with at most one Object Template (for now). Many Runs can reference the same Spec. Each Run must be associated with exactly one Spec. As Object Specs define the intent to do something, they are more limited in possible fields than Runs. Table7 represents what additional fields are required or optional for Object Specs. Field Required/Optional Quantity Possible Spec or Run uids Optional many both tags Optional many both name Required one both notes Optional one both file_links Optional many both template Optional one Spec spec Required one Run Table7 : Shows the fields available for Material, Measurement, and Process Objects in the Spec and Run contexts. Ingredient Objects are treated a little differently from the other Objects in taurus because they are mainly used to annotate a Material with information related to its usage in a Process. Note that constraints on name and labels follow from the allowed_names and allowed_labels fields of the Process Template. Table8 below identifies all the fields available in Ingredient Objects for both Specs and Runs. Field Required/Optional Quantity Possible In Spec or Run uids Optional many both tags Optional many both notes Optional one both file_links Optional many both name Optional one Spec labels Optional many Spec material Required one both (with material object from respective state) mass_fraction Optional one both volume_fraction Optional one both number_fraction Optional one both absolute_quantity Optional one both spec Required one Run Table8 : Shows the fields available for Ingredient Objects in the Spec and Run context.","title":"High Level Overview"},{"location":"high-level-overview/#how-is-data-stored","text":"We have given this format the codename taurus . Taurus stores data via interconnected Data Objects, representing Specs and Runs of Materials, Processing steps, Measurements, and Ingredient information. This format is graphical rather than tabular. It will support a JSON-based serialization, like the PIF , but with links as references rather than nested objects (i.e. subsystems). Conversely, there are many new ideas that exist in taurus that are not captured by the PIF, including: Process history and process order, including the input materials to process steps Conditions that are shared between properties Specified vs actual values Ingredient information of input materials of a process","title":"How is data stored"},{"location":"high-level-overview/#how-are-data-objects-defined","text":"There are four categories of Data Objects in Taurus: Materials, Processes, Measurements, and Ingredients. These represent real world objects in the development of materials. The 4 categories of Data Objects can only be linked in specific ways, for example, a Process Object can only be linked to one or many Material Objects as its input, more details are explained in Table1. Each Object can be represented in 3 different states, these states are defined below, they are Template, Spec, and Run. Note, Ingredient Objects cannot be represented in the Template state. Material Object: Describes a material by a name used in an organization and optional notes to describe it. Measurement Object: Describes an operation used to measure or characterize one or more properties of a material and the parameters and conditions for that operations. Process Object: Describes an operation used with the goal of transforming a material. Ingredient Object: Annotates a material with information related to its usage in a process including name (label on the ingredient that is unique within the process that contains it) and labels (additional labels on the ingredient) Object Examples Linked Objects State Possible Attributes Material Glass, H2O n/a Template Properties ^ ^ input: Process (1); Measurement (0 or many) Spec Properties and Conditions ^ ^ ^ Run none Process Gas pressure sintering, Binder burnout n/a Template Parameters and Conditions ^ ^ input: Ingredient (0 or many); output: Material (1) Spec Parameters and Conditions ^ ^ ^ Run Parameters and Conditions Measurement 3 point bend, combustion analysis n/a Template Properties, Parameters, and Conditions ^ ^ Material (1) Spec Parameters, and Conditions ^ ^ ^ Run Properties, Parameters, and Conditions Ingredient 80wt%, 20lbs, solute Material (1) Spec n/a ^ ^ ^ Run n/a Table1: Shows the relation of Objects to other Objects and Attributes possible in each state.","title":"How are Data Objects defined?"},{"location":"high-level-overview/#how-are-attributes-defined","text":"Each Data Object (except Ingredient Objects) can contain Attributes that describe it. There are three different categories of Attributes: Properties, Parameters, and Conditions. Attributes contain structured materials data that is representative of an Data Object. For example, a Process Object can have Parameters and Conditions as such: \u201csinter at 2400 K for 6 hours in kiln 14\u201d. Property Attribute: Describes a property that is measured or calculated, they are aspects of a material, e.g. \u201cthe hardness of the sample\u201d. Parameter Attribute: Describes the settings of a tool that are set by the user for a specific purpose, e.g. \u201cthe size of the indenter\u201d or \u201cthe grid spacing in a simulation\u201d. Condition Attribute: Describes the aspects of the environment during a process or measurement, e.g. \u201cthe temperature of the environment during measurement\u201d. Each Attribute has specified fields that are required or optional as defined in Table3 and Table6 below.","title":"How are Attributes defined?"},{"location":"high-level-overview/#how-are-states-defined","text":"There are 3 main states in which Data Objects exist: Templates, Spec, and Run. Taurus distinguishes between the generalization of what might be done (Template), the intent to do something (Spec), and the actual result of doing it (Run). As an example, one can have a Template for a Process Object defined as \u201csinter at {temperature} for {time} in kiln {id}\u201d. This would be the Template used for a Spec of a kiln process used in the production of alumina. The Spec of the Process object might be \u201csinter at 2400 K for 6 hours in kiln 14\u201d. The Process Run object would be what really happened when the process was conducted. For example, someone may have run the kiln and it ran at 2395 K. The Run of the Process object would be \u201csinter at 2395 K for 5.75 hours in kiln 14\u201d. All Data Objects (and all the Attributes that describe those Data Objects) in any State have specified fields that are required or optional, Table2 goes into further detail about the possible fields in all Data Objects and Attributes. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one Table2: Defines the possible fields in all Data Objects and Attributes in all states","title":"How are States defined?"},{"location":"high-level-overview/#templates","text":"Templates are generalizations of Data Objects used to standardize data in Taurus. Templates are used at write time to validate data and at read time to associate groups of information together. Each Spec and Run Object or Attribute (excluding Ingredient Objects and Metadata Attributes) requires a linked Template to support this read and write time association and validation respectively.","title":"Templates"},{"location":"high-level-overview/#attribute-templates","text":"An Attribute Template specifies the bounds that are acceptable for an Attribute. For example, an Attribute Template could specify a Real value bounded between -3 and +17, or it could define a Categorical bound with the following allowed categories: \"salt\", \"not salt\". The values of an Attribute with an Attribute Template must conform to the bounds specified by the Template. If the value is not compatible with the Template (e.g. if the Template specifies that the value must be in the range [0, 1] but the value is 2), an error is thrown. Table3 below defines the possible fields in all Attributes in the Template state. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one description Optional one bounds Required one Table3 : Shows the fields available for Attributes in the Template state The scope defines to which category of Attribute (Property, Parameter, or Condition) the Attribute Template applies.","title":"Attribute Templates"},{"location":"high-level-overview/#object-templates","text":"Object Templates are collections of Attribute Templates that together constrain the values of an Data Object's associated Attributes to valid ranges, and provide a common structure for describing similar Data Objects. Object Templates are useful for validating that all Data Objects being written or generated by a script are consistent and valid. In the future, Object Templates could be used to generate data input forms or similar interfaces. Table4 below defines the possible fields in all Data Objects in the Template state. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one description Optional one Table4 : Shows the fields available for each category of Data Object in the Template state All Object Templates can also have additional Attribute Bounds set on defined Attributes. These are additional bounds that can be applied to Attributes associated with that Data Object. For example, consider there exists a Condition Attribute Template called \"Oven Temperature\" that is defined from 0 to 10,000 Kelvin and a Process Object Template that includes the \"Oven Temperature\" Condition Template. Along with the Condition Template \u201cOven Temperature\u201d, the Process Template can include additional Attribute bounds and restrict the values that can be applied to that Condition between 300 and 600 Kelvin. That second restriction is represented by a second bound paired with the Condition Template in the Process Object Template. Table5 below identifies all the possible Attributes that each Data Object can contain in the Template state. Object Template Property Template Parameter Template Condition Template Material Template yes no no Process Template no yes yes Measurement Template yes yes yes Table5 : Shows which Attributes can be linked to each Data Object in the Template state.","title":"Object Templates"},{"location":"high-level-overview/#specs-and-runs","text":"Specs define the intent to do something, usually formalized in the format of an experiment request, the intention of an experiment, or the definition of a property. For example, the normal boiling point of pure water is 99.61 C, a spec. Runs describe how a material, process, or measurement were actually performed, defined, or evaluated and the end results of that evaluation. For example, a sample of water boiled at 101 C, a run.","title":"Specs and Runs"},{"location":"high-level-overview/#attribute-in-specs-and-runs","text":"Each Attribute has specified fields that are required or optional for both Spec or Run state. Table6 goes into further detail about the possible fields. Table6 represents the Attributes in diagram. Field Required/Optional Quantity Possible name Required one value Required one notes Optional one origin Required one template Optional one file_links Optional many Table6 : Shows the fields available for Attributes in the Spec and Run context. All attributes must specify the origin of their data as one of: Specified: it is the intention to have this value Measured: this was directly measured during the process or measurement run Computed: this was calculated based on other measured or derived properties Predicted: this was calculated based on a model, e.g. machine learning or simulation Summary: this was calculated based on a set of the same property at a finer level of granularity (aggregation of data) Unknown: the origin is not known, typically when migrating legacy data A value is a complex type that may contain both central (i.e. expected) and distributional (i.e. uncertainty) information. It also includes units for real (i.e. continuous) values.","title":"Attribute in Specs and Runs"},{"location":"high-level-overview/#data-object-specs-and-runs","text":"Object Specs require an associated Object Template that bounds the valid units and values of the Attributes on the Spec. With the linking of Specs to Runs, Runs inherit associated Templates through Specs. For example, Process Runs associated with a Process Spec inherit the Template associated with the Spec, and their Attributes are thus also constrained by the Template. Many Specs can reference the same Object Template. Each Spec can be associated with at most one Object Template (for now). Many Runs can reference the same Spec. Each Run must be associated with exactly one Spec. As Object Specs define the intent to do something, they are more limited in possible fields than Runs. Table7 represents what additional fields are required or optional for Object Specs. Field Required/Optional Quantity Possible Spec or Run uids Optional many both tags Optional many both name Required one both notes Optional one both file_links Optional many both template Optional one Spec spec Required one Run Table7 : Shows the fields available for Material, Measurement, and Process Objects in the Spec and Run contexts. Ingredient Objects are treated a little differently from the other Objects in taurus because they are mainly used to annotate a Material with information related to its usage in a Process. Note that constraints on name and labels follow from the allowed_names and allowed_labels fields of the Process Template. Table8 below identifies all the fields available in Ingredient Objects for both Specs and Runs. Field Required/Optional Quantity Possible In Spec or Run uids Optional many both tags Optional many both notes Optional one both file_links Optional many both name Optional one Spec labels Optional many Spec material Required one both (with material object from respective state) mass_fraction Optional one both volume_fraction Optional one both number_fraction Optional one both absolute_quantity Optional one both spec Required one Run Table8 : Shows the fields available for Ingredient Objects in the Spec and Run context.","title":"Data Object Specs and Runs"},{"location":"philosophy/","text":"Taurus Philosophy Scope # Taurus records physical and contextual information about materials and chemicals. This includes: Physical properties of materials and chemicals Descriptions of processes and characterizations performed on the material, including who, when, and why Provenance of the materials and chemicals A controlled vocabulary for domain concepts like \"vapor pressure\" and \"universal testing machine\" Objective # Taurus enables information reuse and supports a material and chemicals system of record. Guiding principles # Taurus does not define a controlled vocabulary It is not the place of the data format to say \"Bandgap\" instead of \"band gap\" or \"Young's modulus\" instead of \"Young modulus\". Objects and Attributes have name fields that can take any value. Even the notion of equivalence/comparability is abstracted away to templates (see below), which can be used to define controlled vocabularies in data. Validations define a controlled vocabulary Taurus captures validation in the form of Attribute Templates and Object Templates . These same objects serve to define a controlled vocabulary of domain concepts. The way that taurus indicates that a property is a \"vapor pressure\" vs an \"ambient pressure\" vs a \"pressure applied on the horizontal face\" is by defining templates for each of those concepts and assigning those templates to their corresponding properties. This controlled vocabulary of templates supports robust comparisons. If two attributes define the same attribute template, then they should be directly comparable. On the other hand, if two attributes only define the same dimension (e.g. mass-length-time) then they may correspond to distinct and incomparable physical concepts. Everything is bounded The bounds on real, integer, and categorical values do not support infinity or wildcard categories. If an Attribute is assigned an Attribute Template , then its values must be bounded. The utility is that those bounds define either a finite set of options the attribute might take, for categorical and integer types, or a finite range for real types. This defines a scale for evaluating how similar two attributes are set to select values from when inputting or generating data. How do we get away with this requirement? The universe only has so much energy, so there is a practical upper limit to most physical quantities. More practically, the physical systems present in materials and chemicals can range considerably in size, but not infinitely so. When defining the bounds in templates, it is important to have a broad ranges of use cases in mind. Attribute Templates should contain especially broad ranges, while Object Templates can refine those ranges to a tighter scope of application. Never turn away data If the data is in scope, then the data model should have a place to write it. Catch-all fields, e.g. notes , are useful, but common notes patterns should be elevated into the spec. When linking data, the data author should be blocked by other data authors as infrequently as possible. Another consequence of never wanting to turn data away is that curation via template assignment is optional. It is better to have data with only unstructured context, e.g. notes, than to reject data because the user cannot or does not assign a template. This is particularly true for implementations that control the generation of templates, limiting the ability of any user to define an appropriate template. Process is a first-class citizen The same stuff processed in different ways results in different materials, so the process by which a material was created belongs on equal footing with the material itself. In taurus, they are in a 1:1 correspondence with each other: every material object has a process object that produced it. It is required because a material cannot be described without describing its process. Multiple authors can contribute to the history of a material Over its lifetime, a material and its precursors frequently change hands. Consequently, the people who know about each processing and measurement step can be different. In extreme cases, a third party measurement might be deliberately blinded to the description of the sample being tested. The data model supports this by encoding information about a material in a set of objects, each scoped to contain the information that an individual or team would have. Each individual or team owns their steps in the process, but doesn't need to worry about the downstream steps. The objects are linked in a chronological order from oldest to most recent. We don't always get what we want But if we try sometimes, we record what we'll need later. Taurus distinguishes between the intent to do something (a Spec) and the reality of what happened (a Run). Further, a single intent can be realized multiple times. This lets taurus capture both systematic and random errors. It also allows for the definition of intent to precede generation of physical artifacts, supporting information hand-offs to experimental groups. Uncertainty quantification is opt-out rather than opt-in No measurement can be absolutely certain, and no calculation derived from uncertain inputs can magically produce certain outputs. Capturing that uncertainty is incredibly valuable as it informs a wide variety of statistical analyses. Uncertainty can take many forms, which are represented by a variety of distribution Value Types , which must be used when recording physical information into Attributes . However, uncertainty quantification can be challenging and is often impossible in hindsight. Therefore, nominal values are permitted to express \"It was nominally X, but we don't know how certain we are about it.\" Material history is chronological For any given physical object, one can trace back the series of processes that generated it and the ingredient materials that went into those processes. We represent this chronological history as a directed acyclic graph where each material links to the process that created it and each process links to the materials that went into it. Each of those input materials must exist before the process occurs. As a consequence there can be no cycles in a well-formed material history, as that would imply a material being created and then traveling back in time to be used in one of the processes that were involved in creating it. Starting from a root material and following references in the material->process->ingredient->material order, one can traverse the entire history and never see the same object twice.","title":"Taurus Philosophy"},{"location":"philosophy/#scope","text":"Taurus records physical and contextual information about materials and chemicals. This includes: Physical properties of materials and chemicals Descriptions of processes and characterizations performed on the material, including who, when, and why Provenance of the materials and chemicals A controlled vocabulary for domain concepts like \"vapor pressure\" and \"universal testing machine\"","title":"Scope"},{"location":"philosophy/#objective","text":"Taurus enables information reuse and supports a material and chemicals system of record.","title":"Objective"},{"location":"philosophy/#guiding-principles","text":"","title":"Guiding principles"},{"location":"specification/attribute-templates/","text":"Attribute Templates and Bounds An AttributeTemplate defines a domain concept by giving it a canonical name and bounds, which describes the values that are acceptable for an Attribute. For example, an attribute template could define a real value bounded between -3 and +17, or it could define a Categorical with the following allowed categories: \"salt\", \"not salt\". The values of an attributes with an Attribute Template must conform to the bounds specified by the template. If the value is not compatible with the template (e.g. if the template specifies that the value must be in the range [0, 1] but the value is 2), then the data are invalid. Each AttributeTemplate is primarily defined by a name , bounds . AttributeTemplates can also be described with tags, description, and scope. Field name Value type Default Description type String Req. One of: property_template , condition_template , parameter_template name String Req. The name of the template bounds Bounds Req. Description of values that are valid according to the template (see below) uids Map[String, String] Empty A collection of Unique Identifiers description String None Some text describing what this template is tags Set[String] Empty set Tags Constraints Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded Real Bounds # Real bounds are defined by a range of finite real values and a unit. For example: The band gap is defined from zero to 20 eV The lowest unoccupied molecular orbital (LUMO) is defined from negative 100 to zero eV The volume fraction in the austenite phase is defined from 0.0 to 1.0 and is dimensionless Real bounds can validate distributions over the real numbers. A real-valued distribution may be non-zero for points outside of the associated real bounds and still be valid. This is because common distributions such as a Gaussian are non-zero everywhere. If a Real Value is allowed to be non-zero outside the associated bounds, the conditions for validation are documented in the description of that type. Field name Value type Description type String always real_bounds default_units String Unit used to express the bounds lower_bound Number the lower bound upper_bound Number the upper bound Constraints Field name Relationship Field Name lower_bound <= upper_bound Example { \"type\" : \"real_bounds\", \"default_units\" : \"meters\", \"lower_bound\" : 0.0, \"upper_bound\" : 10.0 } Integer Bounds # Integer bounds are defined by a range of integer values. For example: The number of power-cycles in a battery lifetime test is between 1 and 1,000,000 The position of a digital knob is between 1 and 10 The charge on an ion is between -128 and 128 Field name Value type Description type String always integer_bounds lower_bound Integer the inclusive lower bound upper_bound Integer the inclusive upper bound Constraints Field name Relationship Field Name lower_bound <= upper_bound Example { \"type\" : \"integer_bounds\", \"lower_bound\" : -128, \"upper_bound\" : 128 } Categorical Bounds # Categorical bounds are defined by a set of valid category names. For example: Colors are one of: \"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Purple\" Answers are one of: \"Animal\", \"Vegetable\", \"Mineral\" Fats are one of: \"Saturated\", \"Mono-unsaturated\", \"Poly-unsaturated\" Field name Value type Description type String always categorical_bounds categories Set[String] A set of valid categorical values Example { \"type\" : \"categorical_bounds\", \"categories\" : [ \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\" ] } Composition Bounds # Composition bounds are defined by a set of valid component names. For example: Steel phase is a mixture of Austentite, Allotriomorphic ferrite, Idiomorphic ferrite, Pearlite, ... (there are 10) Elemental composition is a mixture of the elements Vodka is a mixture of water, ethanol, and contaminants Field name Value type Description type String always composition_bounds components Set[String] A set of valid component names Example { \"type\" : \"composition_bounds\", \"components\" : [ \"water\", \"ethanol\", \"contaminants\" ] } Molecular Structure Bounds # Molecular structure bounds are used to describe an attribute template that expects a molecular structure type, but do not have any further parameterization. For example: Ligand structure is molecular structure Monomer is a molecular structure Field name Value type Description type String always molecular_structure_bounds Example { \"type\" : \"molecular_structure_bounds\" } Example Attribute Templates { \"type\" : \"property_template\", \"uids\" : { \"id\" : \"2e1bec7e-bda4-441d-bebb-1215bfa6ee0f\" }, \"tags\" : [ \"hardness::indentation::vickers\", \"Newage MT91 Tester::004\", \"astm_hardness::ASTM E-384\"], \"name\" : \"Vickers Hardness on Machine 4\", \"description\" : \"A Vickers indentation hardness test on the Newage MT91 Tester with machine id #4. Conforms to ASTM standard E-384.\", \"bounds\" : { \"type\" : \"real_bounds\", \"default_units\" : \"HV30/15\", \"lower_bound\" : 0.0, \"upper_bound\" : 10000.0 } } { \"type\": \"property_template\", \"id\" : \"2e1bec7e-bda4-441d-bebb-1215bfa6ee0f\", \"uids\" : {}, \"tags\" : [ \"#noindigo::newtonwaswrong\", \"taste::therainbow\", \"things_they_are_after::my_lucky_charms\", \"marketing::commercials::candy::skittles\", \"marketing::characters::cereal::leprechaun\" ], \"name\" : \"Rainbow Colors\", \"description\" : \"Colors in the rainbow\", \"bounds\" : { \"type\" : \"categorical_bounds\", \"categories\" : [ \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\" ] } }","title":"Attribute Templates and Bounds"},{"location":"specification/attribute-templates/#real-bounds","text":"Real bounds are defined by a range of finite real values and a unit. For example: The band gap is defined from zero to 20 eV The lowest unoccupied molecular orbital (LUMO) is defined from negative 100 to zero eV The volume fraction in the austenite phase is defined from 0.0 to 1.0 and is dimensionless Real bounds can validate distributions over the real numbers. A real-valued distribution may be non-zero for points outside of the associated real bounds and still be valid. This is because common distributions such as a Gaussian are non-zero everywhere. If a Real Value is allowed to be non-zero outside the associated bounds, the conditions for validation are documented in the description of that type. Field name Value type Description type String always real_bounds default_units String Unit used to express the bounds lower_bound Number the lower bound upper_bound Number the upper bound","title":"Real Bounds"},{"location":"specification/attribute-templates/#integer-bounds","text":"Integer bounds are defined by a range of integer values. For example: The number of power-cycles in a battery lifetime test is between 1 and 1,000,000 The position of a digital knob is between 1 and 10 The charge on an ion is between -128 and 128 Field name Value type Description type String always integer_bounds lower_bound Integer the inclusive lower bound upper_bound Integer the inclusive upper bound","title":"Integer Bounds"},{"location":"specification/attribute-templates/#categorical-bounds","text":"Categorical bounds are defined by a set of valid category names. For example: Colors are one of: \"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Purple\" Answers are one of: \"Animal\", \"Vegetable\", \"Mineral\" Fats are one of: \"Saturated\", \"Mono-unsaturated\", \"Poly-unsaturated\" Field name Value type Description type String always categorical_bounds categories Set[String] A set of valid categorical values","title":"Categorical Bounds"},{"location":"specification/attribute-templates/#composition-bounds","text":"Composition bounds are defined by a set of valid component names. For example: Steel phase is a mixture of Austentite, Allotriomorphic ferrite, Idiomorphic ferrite, Pearlite, ... (there are 10) Elemental composition is a mixture of the elements Vodka is a mixture of water, ethanol, and contaminants Field name Value type Description type String always composition_bounds components Set[String] A set of valid component names","title":"Composition Bounds"},{"location":"specification/attribute-templates/#molecular-structure-bounds","text":"Molecular structure bounds are used to describe an attribute template that expects a molecular structure type, but do not have any further parameterization. For example: Ligand structure is molecular structure Monomer is a molecular structure Field name Value type Description type String always molecular_structure_bounds","title":"Molecular Structure Bounds"},{"location":"specification/attributes/","text":"Attributes Properties are characteristics of a material that could be measured, e.g. chemical composition, density, or yield strength. I recorded a measurement run of the density of my cookie. I measured the property to be a Nominal Real Value of 604 kg/m\u00b3. Conditions are the environmental variables (typically measured) that may affect a process or measurement: e.g. Temperature, Pressure. \"The reading on the thermometer inside my oven as I bake cookies was 355 degrees, and I know that my thermometer is only accurate to +- 5 degrees, so I'll make that a Uniform Real Value with a lower_bound of 350 and an upper_bound of 360. Parameters are the non-environmental variables (typically specified and controlled) that may affect a process or measurement: e.g. Oven Dial Temperature Position for a kiln firing, or Magnification for a measurement taken with a SEM. The \"Bake Cookies\" Process Spec has two parameters: a Nominal Real Value of 30 minutes for bake duration, and a Nominal Real Value of 350 degrees for oven temperature setting I know my oven tends to run cold, so as I was baking I set my temperature setting to 360 degrees. I recorded this in the process run as a parameter with a Nominal Real Value of 360 Degrees. Typically, conditions are going to apply to measured environmental variables in process runs and measurement runs. It may be appropriate to specify a Parameter attribute on a Spec, and describe that attribute as a Condition on Runs of that Spec if the value is being measured as opposed to controlled during the Run. It may also be appropriate to include both a Parameter and a Condition on the Run if the value is both controlled and measured. The use of Conditions in Specs should be limited in favor of parameters. Attributes are annotated with the origin of the data. This field can have the following values: measured : The Value of this Attribute was directly measured. predicted : The Value of this Attribute came from a model, such as a complex simulation, a machine learning-derived computation or rule-of-thumb estimation specified : The Value of this Attribute was dictated, such as the oven temperature in a Process Spec . This value should only appear in Specs. computed : The Value of this Attribute was derived directly from measured values, such as computing the yield stress from a stress-strain curve or computing the density from known mass and volume measurements. unknown : The origin of this Value is unknown. This is the default value. Attributes may be annotated with an Attribute Template , which defines a canonical name and bounds on the attribute. Property, Condition, Parameter # All three types of attributes have the same fields. Field name Value type Default Description type String Req. One of: property , condition , parameter value Value Req. Any Value type name String Req. The name of the attribute, which is used to identify it within a Data Object notes String None Some free-form notes about the attribute. origin measured , predicted , specified , computed , unknown unknown The origin of the attribute template Attribute Template None Attribute Template which defines bounds file_links Set [File Links ] Empty set Links to associated files, with resource paths into the files API Constraints Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( notes ) <= 32,768 (32KB), UTF-8 Encoded template is a template type that matches the attribute type, e.g. PropertyTemplate for a Property value is a template 's Value Type value conforms to template . bounds Examples { \"type\" : \"property\", \"name\" : \"A Real Valued Property\", \"value\" : { \"type\" : \"uniform_real\", \"lower_bound\" : 1.995, \"upper_bound\" : 2.005, \"units\": \"inch\" }, \"origin\" : \"measured\", \"template\" : { \"name\" : \"A Property Template\", \"type\" : \"property_template\", \"bounds\" : { \"type\" : \"real_bounds\", \"lower_bound\" : 0.0, \"upper_bound\" : 10.0, \"default_units\": \"meters\" } }, \"file_links\" : [ { \"filename\" : \"How-to-make-lucky-charms.pdf\", \"link\" : \"files/file/d8f12919-b201-4186-be95-10525eb4256a/version/2\" } ] } { \"type\" : \"condition\", \"value\" : { \"type\" : \"uniform_real\", \"lower_bound\" : 1.0, \"upper_bound\" : 2.0, \"units\": \"degC\" }, \"origin\" : \"measured\", \"template\" : { \"type\" : \"condition_template\", \"name\" : \"temperature\", \"bounds\" : { \"type\" : \"real_bounds\", \"lower_bound\" : 0.0, \"upper_bound\" : 1.0e6, \"default_units\": \"Kelvin\" } } } { \"type\" : \"parameter\", \"value\" : { \"type\" : \"nominal_real\", \"nominal\" : 1.0, \"units\": \"degC\" }, \"origin\" : \"specified\", } Properties and Conditions # In the Material Spec object, one may need to specify a property along with the conditions under which the property occurs. For example: Vapor pressure of 5.6 kPa at a temperature of 35 deg C Gas phase at a pressure of 1 kPa and a temperature of 300 K This is supported by the PropertiesAndConditions compound attribute. Field name Value type Default Description type String Req. property_and_conditions property Property Req. Any Property attribute conditions Set[Conditions] Empty set Any conditions associated with the property","title":"Attributes"},{"location":"specification/attributes/#property-condition-parameter","text":"All three types of attributes have the same fields. Field name Value type Default Description type String Req. One of: property , condition , parameter value Value Req. Any Value type name String Req. The name of the attribute, which is used to identify it within a Data Object notes String None Some free-form notes about the attribute. origin measured , predicted , specified , computed , unknown unknown The origin of the attribute template Attribute Template None Attribute Template which defines bounds file_links Set [File Links ] Empty set Links to associated files, with resource paths into the files API","title":"Property, Condition, Parameter"},{"location":"specification/attributes/#properties-and-conditions","text":"In the Material Spec object, one may need to specify a property along with the conditions under which the property occurs. For example: Vapor pressure of 5.6 kPa at a temperature of 35 deg C Gas phase at a pressure of 1 kPa and a temperature of 300 K This is supported by the PropertiesAndConditions compound attribute. Field name Value type Default Description type String Req. property_and_conditions property Property Req. Any Property attribute conditions Set[Conditions] Empty set Any conditions associated with the property","title":"Properties and Conditions"},{"location":"specification/file-links/","text":"File Links Data objects are commonly derived from or related to files, e.g. the excel sheet from which a property was ingested, or an SEM image associated with a measurement, or a PDF describing detailed information for how to execute a process. Objects can reference those files using FileLink s, which simply specify a filename and url. Field name Value type Description filename String The name of the file url String The url at which the file (and associated metadata) can be accessed Constraints None Example { \"file_links\" : [ { \"filename\" : \"How-to-make-lucky-charms.pdf\", \"url\" : \"https://example.com/files/file/d8f12919-b201-4186-be95-10525eb4256a/version/2\" } ] }","title":"File Links"},{"location":"specification/object-templates/","text":"Object Templates Object Templates, like Attribute Templates, define a domain concept, e.g. convection baking in a standard residential oven, a cheesecake, or a taste test. Unlike Specs, Object Templates define ranges validity. Object Templates contain collections of Attribute Templates that together constrain the values of an object's associated attributes to valid ranges. They also define a canonical name, a description, and can be tagged. The parameters , properties , and conditions fields in Object Templates are defined as sets of pair. Each pair contains at Attribute Template and a Bounds that further constraints the bounds in the Attribute template. For example, the baking temperature might generally be defined to be between 100 degF and 1500 degF, but a Process Template describing a specific oven model may constrain the baking temperature to be between 150 degF and 550 degF. The Bounds must fall within the Attribute Template's Bounds, and should be set to those Bounds if no further constraint is desired. Each Attribute Template can only be included in a given Object Template's Attribute list once (e.g., once in properties and once in conditions ). Process Template # Process templates are further able to constrain the names and labels on their ingredients. If those sets are empty, then no constraint is implied. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"process_template\" tags Set[String] Empty set Tags name String Req. The name of the template allowed_names Set[String] Empty set The set of names that ingredients are allowed to use in their name field allowed_labels Set[String] Empty set The set of labels that ingredients are allowed to use in their labels field description String None Some text describing what this template is for. conditions Set[Pair( Condition Templates , Bounds )] Empty set Templates for associated conditions and bounds narrowing the allowable range parameters Set[Pair( Parameter Templates , Bounds )] Empty set Templates for associated parameters and bounds narrowing the allowable range Constraints Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded Bounds contained in Attribute template bounds parameters templates are unique within parameters condition templates are unique within conditions Example This is an example of a process template that has fully represented attribute templates. { \"type\" : \"process_template\", \"uids\" : { \"cookie_templates\" : \"baking_process_01\", \"id\" : \"064148e6-1cce-4d89-bfde-7ecd0aa4632b\" }, \"tags\" : [ \"baking::cookies\" ], \"name\" : \"Bake Cookies\", \"description\" : \"Template for baking cookies in an oven\", \"parameters\" : [ [ { \"name\" : \"Oven Temperature\", \"uids\" : {\"cookie_templates\": \"oven_temp\"}, \"tags\" : [\"oven_settings::temperature\"], \"description\" : \"A template for valid temperature ranges for baking cookies. Below 328K you're not even pasteurizing the dough.\", \"bounds\" : { \"default_units\" : \"kelvin\", \"type\" : \"real_bounds\", \"lower_bound\" : 328, \"upper_bound\" : 750 } }, { \"type\" : \"real_bounds\", \"default_units\" : \"kelvin\", \"lower_bound\" : 400, \"upper_bound\" : 500 } ], [ { \"name\" : \"Baking Time\", \"uids\" : {\"cookie_templates\": \"oven_time\"}, \"tags\" : [\"oven_settings::duration\"], \"description\" : \"A template for valid duration ranges for baking cookies.\", \"bounds\" : { \"default_units\" : \"seconds\", \"type\" : \"real_bounds\", \"lower_bound\" : 0, \"upper_bound\" : 86400 } }, { \"type\" : \"real_bounds\", \"default_units\" : \"seconds\", \"lower_bound\" : 300, \"upper_bound\" : 7200 } ] ] } Material Template # The Property Templates and Bounds contained in a material template are used to validate the properties in any PropertyAndCondition s in the Material Spec . They are not, however, used to validate the properties in any Measurement Run objects attached to the Material Run . Rather, those properties are validated by the Measurement Template . Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"material_template\" tags Set[String] Empty set Tags name String Req. The name of the template description String None Some text describing what this template is for. properties Set[Pair( Property Templates , Bounds )] Empty set Templates for associated properties and bounds narrowing the allowable range Constraints Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded property templates are unique within properties Examples { \"type\" : \"material_template\", \"uids\" : { \"cookie_templates\" : \"choc_chip\", \"id\" : \"2e1bec7e-bda4-441d-bebb-1215bfa6ee0f\" }, \"tags\" : [], \"name\" : \"Chocolate Chip Cookie Template\", \"description\" : \"Template for chocolate chip cookie materials\", \"properties\" : [ [ { \"uids\" : {\"cookie_templates\" : \"choc_chip_comp_01\"}, \"tags\" : [\"ingredients::cookies::nutsallowed\"], \"name\" : \"Chocolate Chip Cookie Composition\", \"description\" : \"Specifying the composition of the linked cookie\", \"bounds\" : { \"type\" : \"categorical_bounds\", \"categories\" : [ \"flour\", \"baking soda\", \"baking powder\", \"salt\", \"butter\", \"granulated sugar\", \"brown sugar\", \"vanilla extract\", \"eggs\", \"chocolate chips\", \"chopped nuts\" ] } }, { \"type\" : \"categorical_bounds\", \"categories\" : [ \"flour\", \"baking soda\", \"baking powder\", \"salt\", \"butter\", \"granulated sugar\", \"brown sugar\", \"vanilla extract\", \"eggs\", \"chocolate chips\", \"chopped nuts\" ] } ] ] } Measurement Template # Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"measurement_template\" tags Set[String] Empty set Tags name String Req. The name of the template description String None Some text describing what this template is for. conditions Set[Pair( Condition Templates , Bounds )] Empty set Templates for associated conditions and bounds narrowing the allowable range parameters Set[Pair( Parameter Templates , Bounds )] Empty set Templates for associated parameters and bounds narrowing the allowable range properties Set[Pair( Property Templates , Bounds )] Empty set Templates for associated properties and bounds narrowing the allowable range Constraints Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded property templates are unique within properties parameters templates are unique within parameters condition templates are unique within conditions Examples { \"type\" : \"measurement_template\", \"uids\" : { \"cookie_templates\" : \"choc_chip_hedonic\", \"id\" : \"664e5b79-4c16-46db-aa9e-ff70d79d2f79\" }, \"tags\" : [], \"name\" : \"Chocolate Chip Cookie Hedonic Index Measurement Template\", \"description\" : \"Template for chocolate chip cookie materials\", \"properties\" : [ [ { \"uids\" : {\"cookie_templates\": \"hedonic_index_prop\"}, \"tags\" : [], \"name\" : \"Chocolate Chip Cookie Hedonic Index\", \"description\" : \"The allowable range for the hedonic index of chocolate chip cookies.\", \"bounds\" : { \"type\" : \"real_bounds\", \"lower_bound\" : 9.99, \"upper_bound\" : 10, \"default_units\" : \"\" } }, { \"type\" : \"real_bounds\", \"lower_bound\" : 9.99, \"upper_bound\" : 10, \"default_units\" : \"\" } ] ], \"conditions\" : [ [ { \"name\" : \"Cookie Temperature\", \"uids\" : {\"cookie_templates\": \"cookie_eating_temp\"}, \"tags\" : [], \"description\" : \"A template for valid temperature ranges for eating cookies.\", \"bounds\" : { \"default_units\" : \"kelvin\", \"type\" : \"real_bounds\", \"lower_bound\" : 250, \"upper_bound\" : 380 } }, { \"default_units\" : \"kelvin\", \"type\" : \"real_bounds\", \"lower_bound\" : 250, \"upper_bound\" : 380 } ] ], \"parameters\": [ [ { \"name\" : \"Number of Cookies\", \"uids\" : {\"cookie_templates\": \"cookie_count\"}, \"tags\" : [\"chocula\"], \"description\" : \"A template for the number of cookies to eat for a hedonic index test.\", \"bounds\" : { \"type\" : \"integer_bounds\", \"lower_bound\" : 1, \"upper_bound\" : 1000 } }, { \"type\" : \"integer_bounds\", \"lower_bound\" : 1, \"upper_bound\" : 1000 } ] ] }","title":"Object Templates"},{"location":"specification/object-templates/#process-template","text":"Process templates are further able to constrain the names and labels on their ingredients. If those sets are empty, then no constraint is implied. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"process_template\" tags Set[String] Empty set Tags name String Req. The name of the template allowed_names Set[String] Empty set The set of names that ingredients are allowed to use in their name field allowed_labels Set[String] Empty set The set of labels that ingredients are allowed to use in their labels field description String None Some text describing what this template is for. conditions Set[Pair( Condition Templates , Bounds )] Empty set Templates for associated conditions and bounds narrowing the allowable range parameters Set[Pair( Parameter Templates , Bounds )] Empty set Templates for associated parameters and bounds narrowing the allowable range","title":"Process Template"},{"location":"specification/object-templates/#material-template","text":"The Property Templates and Bounds contained in a material template are used to validate the properties in any PropertyAndCondition s in the Material Spec . They are not, however, used to validate the properties in any Measurement Run objects attached to the Material Run . Rather, those properties are validated by the Measurement Template . Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"material_template\" tags Set[String] Empty set Tags name String Req. The name of the template description String None Some text describing what this template is for. properties Set[Pair( Property Templates , Bounds )] Empty set Templates for associated properties and bounds narrowing the allowable range","title":"Material Template"},{"location":"specification/object-templates/#measurement-template","text":"Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"measurement_template\" tags Set[String] Empty set Tags name String Req. The name of the template description String None Some text describing what this template is for. conditions Set[Pair( Condition Templates , Bounds )] Empty set Templates for associated conditions and bounds narrowing the allowable range parameters Set[Pair( Parameter Templates , Bounds )] Empty set Templates for associated parameters and bounds narrowing the allowable range properties Set[Pair( Property Templates , Bounds )] Empty set Templates for associated properties and bounds narrowing the allowable range","title":"Measurement Template"},{"location":"specification/objects/","text":"Objects There are two kinds of objects: Specs and Runs. Specs represent the intent and expectation of the material, process, ingredient, or measurement, while Runs capture what actually happened. This captures natural variations and forms an association between samples and design as multiple Runs of the same Spec. Specs are specific. In MaterialSpec , ProcessSpec , IngredientSpec , and MeasurementSpec objects, value should be given nominal values, e.g.: real-valued attributes on Specs should have Nominal Values . This is in contrast to another common usage of the term \"Specification\" (or tolerance) as a range of accepted values, e.g. \"The material is in spec if the nitrogen impurity concentration is below 0.1%.\" In this data model, that notion of a \"spec\" that an object can \"be in\" is an Object Template . Specs can have an Object Template associated, which bounds the valid units and values of the Attributes on the Spec. Object Runs associated with an object Spec inherit the Object Template associated with the Spec, and their Attributes are thus also constrained by the Object Template . Many Specs can reference the same Object Template. Each Spec can be associated with at most one Object Template. Many Runs can reference the same Spec. Each Run must be associated with exactly one Spec. The mechanism for Attribute validation is through Attribute Templates . If the Attribute's template is set, the Attribute's Value is validated against the constraints defined in that template. If the Object Template has further restricted the bounds of the Attribute Template, then those tighter constraints are enforced. The Properties, Parameters and Conditions of Object Templates and of Objects are matched when they point at the same Attribute Template. An Object can have Attributes that are not defined in its Object Template , and an Object Template can have Attributes that are not defined in associated Objects. However, an Object cannot have two attributes of the same type (Property, Parameter, or Condition) with the same name or the same attribute template. Process Spec # An expectation of a process. Processes transform zero or more input materials into exactly one output material. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"process_spec\" name String Req. The name of the spec notes String None Some free-form notes about the spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Process Template None A template bounding the valid values for parameters and conditions on this process. parameters Set[ Parameters ] Empty Specified parameters for the process spec conditions Set[ Conditions ] Empty Specified conditions for the process spec ingredients Set[ Ingredient Spec ] Empty Ingredient Specs output_material Material Spec Req. Output Material Spec Constraints All Attributes sharing an Attribute Template with an Attribute on the associated Object Template will be constrained by the (potentially tighter) bounds set in the template Process Template. Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded parameter names must be unique among parameter names condition names must be unique among condition names parameter templates must be unique among the templates of parameters condition templates must be unique among the templates of conditions output_material must be unique globally Example { \"type\" : \"process_spec\", \"uids\" : { \"id\" : \"064148e6-1cce-4d89-bfde-7ecd0aa4632b\" }, \"tags\" : [ \"baking::cookies\" ], \"name\" : \"Bake Cookies\", \"notes\" : \"Process Spec for baking cookies in an oven\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"baking_process_01\" }, \"file_links\" : [ { \"filename\" : \"nestle-tollhouse-recipe.pdf\", \"url\" : \"https://example.com/file/d8f12919-b201-4186-be95-10525eb4256a/version/2\" } ], \"parameters\" : [ { \"type\" : \"parameter\", \"name\" : \"Oven Temperature\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"oven_temp\" }, \"tags\" : [\"oven_settings::duration\"], \"value\" : { \"type\" : \"nominal_real\", \"nominal\" : 450, \"units\" : \"kelvin\" } }, { \"type\" : \"parameter\", \"name\" : \"Baking Time\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"oven_time\" }, \"tags\" : [\"oven_settings::duration\"], \"value\" : { \"type\" : \"nominal_real\", \"units\" : \"seconds\", \"nominal\" : 600 } } ], \"ingredients\" : [ { \"type\" : \"link_by_uid\", \"scope\" : \"cookie ingredients\", \"id\" : \"chocolate chip cookie batter\" }, { \"type\" : \"link_by_uid\", \"scope\" : \"secret ingredients\", \"id\" : \"love\" } ], \"output_material\" : { \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"18d95397-4887-48f0-bdda-94a9a4c5ef45\" } } Process Run # A particular instance of a process. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"process_run\" name String Req. The name of the process run notes String None Some free-form notes about the process run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API source Source None provenance information for the process spec Process Spec Req. Spec for this process parameters Set[ Parameters ] Empty Measured parameters for the process run conditions Set[ Conditions ] Empty Measured conditions for the process run ingredients Set[ Ingredient Run ] Empty Ingredient Runs output_material Material Run Req. Output Material Run Constraints Same as ProcessSpec , but with the template inherited from the spec , i.e. spec.template . Example { \"type\" : \"process_run\", \"uids\" : { \"cookie_ids\" : \"choc_chip_proc_001_run_006\", \"id\" : \"ea7af3f4-8dbf-41ba-8084-c6f2e31907a5\" }, \"tags\" : [ \"baking::cookies\" ], \"name\" : \"Bake Cookies Fo' Real\", \"notes\" : \"Process run baking some chocolate chip cookies in an oven\", \"process_spec\" : { \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"064148e6-1cce-4d89-bfde-7ecd0aa4632b\" }, \"parameters\" : [ { \"type\" : \"parameter\", \"name\" : \"Oven Temperature\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"oven_temp\" }, \"tags\" : [\"oven_settings::temperature\"], \"value\" : { \"type\" : \"uniform_real\", \"lower_bound\" : 447.5, \"upper_bound\" : 452.5, \"units\" : \"kelvin\" } }, { \"type\" : \"parameter\", \"name\" : \"Baking Time\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"oven_time\" }, \"tags\" : [\"oven_settings::duration\"], \"value\" : { \"type\" : \"nominal_real\", \"units\" : \"seconds\", \"nominal\" : 614 } } ], \"ingredients\" : [ { \"type\" : \"link_by_uid\", \"scope\" : \"cookie ingredients\", \"id\" : \"chocolate chip cookie batter #45 in cookie 6\" }, { \"type\" : \"link_by_uid\", \"scope\" : \"secret ingredients\", \"id\" : \"love #724 in cookie 6\" } ], \"output_material\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie ids\", \"id\" : \"chocolate_chip_00038\" } } Ingredient Spec # The intent for an ingredient, which annotates a material with information related to its usage in an individual process. Note that the name and labels for an Ingredient Spec are shared with all associated Ingredient Runs. These might be better thought of as the name of the role of a material in the process (e.g., binder) and not of the material itself (e.g., portland cement). Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"ingredient_spec\" name String Req. The name of the ingredient, unique within the process that contains it labels Set[String] Empty Additional labels on the ingredient for describing the type or role of the ingredient material Material Spec Req. Material that is this ingredient process Process Spec Req. Process that the ingredient is used in notes String Empty Some free-form notes about the spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API mass_fraction Real Value None The mass fraction of the ingredient in the process volume_fraction Real Value None The volume fraction of the ingredient in the process number_fraction Real Value None The number fraction (i.e., mole fraction) of the ingredient in the process absolute_quantity Real Value None The absolute quantity of the ingredient in the process Note that \"fraction of the ingredient\" refers to the amount of the ingredient divided by the total amount of material going into the process, not the fraction of the total amount of ingredient.material used in the process. Constraints Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded mass_fraction <= 1 volume_fraction <= 1 number_fraction <= 1 mass_fraction.units == dimensionless volume_fraction.units == dimensionless number_fraction.units == dimensionless name must be unique among the ingredients of process name must be contained process.template.allowed_names , if allowed_names defined labels must be contained process.template.allowed_labels , if allowed_labels defined Example { \"type\" : \"ingredient_spec\", \"material\" :{ \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"18d95397-4887-48f0-bdda-94a9a4c5ef45\" }, \"process\" :{ \"type\" : \"link_by_uid\", \"scope\" : \"my_scope\", \"id\" : \"a-cool-process\" }, \"uids\" : { \"cookie_ids\" : \"choc_chip_spec_001_in_sandwich\" }, \"notes\" : \"Chocolate chip cookies used in making an ice cream sandwich\", \"absolute_quantity\" : { \"type\" : \"nominal_integer\", \"nominal\" : 2 }, \"mass_fraction\" : { \"type\" : \"nominal_real\", \"nominal\" : 0.35 }, \"name\" : \"cookie\", \"labels\" : [\"faces\"] } Ingredient Run # A particular instance of an ingredient spec. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"ingredient_run\" material Material Run Req. Material that is this ingredient process Process Run Req. Process that the ingredient is used in notes String None Some free-form notes about the run. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API mass_fraction Real Value None The mass fraction of the ingredient in the process volume_fraction Real Value None The volume fraction of the ingredient in the process number_fraction Real Value None The number fraction of the ingredient in the process absolute_quantity Real Value None The absolute quantity of the ingredient in the process spec Ingredient Spec Req. The spec of which this is a run Note that \"fraction of the ingredient\" refers to the amount of the ingredient divided by the total amount of material going into the process, not the fraction of the total amount of ingredient.material used in the process. Constraints Field name Relationship Field Name mass_fraction <= 1 volume_fraction <= 1 number_fraction <= 1 mass_fraction.units == dimensionless volume_fraction.units == dimensionless number_fraction.units == dimensionless An Ingredient Run and its spec must be paired with a linked Material Run/Spec pair and with a linked Process Run/Spec pair. The spec's process and the process's spec must point to the same Process Spec. The spec's material and the material's spec must point to the same Material Spec. Field name Relationship Field Name process.spec = spec.process material.spec = spec.material Example { \"type\" : \"ingredient_run\", \"material\" :{ \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"18d95397-4887-48f0-bdda-94a9a4c5ef45\" }, \"process\" :{ \"type\" : \"link_by_uid\", \"scope\" : \"my_scope\", \"id\" : \"a-cool-process\" }, \"uids\" : { \"cookie_ids\" : \"choc_chip_run_4_in_sandwich_7\" }, \"notes\" : \"Chocolate chip cookie batch 4 used in making an ice cream sandwich batch 7\", \"absolute_quantity\" : { \"type\" : \"uniform_integer\", \"lower_bound\" : 2, \"upper_bound\" : 2 }, \"mass_fraction\" : { \"type\" : \"normal_real\", \"mean\" : 0.347, \"std\" : 0.002 } } Material Spec # The expectation for a material. Materials have exactly one producing process. Material specs may include expected properties, but do so via the PropertiesAndConditions compound attribute. In this way, material specs can associate an expected property value with the conditions under which it is expected. For example, if a material is purchased and its Safety Data Sheet quotes a normal boiling point of 54 C, a property is known even though there is never an explicit measurement of that property by a person in the lab. It could therefore be annotated with a Boiling Temperature of 54 C (property) at 1 atm (condition). Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"material_spec\" name String Req. The name of the spec notes String None Some free-form notes about the spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Material Template None A template bounding the valid values for properties of this material. properties Set[ PropertiesAndConditions ] Empty Expected properties for the material spec process Process Spec Req. The Process Spec that produces this material Constraints All Attributes sharing an Attribute Template with an Attribute on the associated Object Template will be constrained by the (potentially tighter) bounds set in the template Material Template. Field name Relationship Field Name property names must be unique among property names process must be unique globally Example { \"type\" : \"material_spec\", \"uids\" : { \"cookie_ids\" : \"choc_chip_spec_001\", \"id\" : \"18d95397-4887-48f0-bdda-94a9a4c5ef45\" }, \"name\" : \"Chocolate Chip Cookie Spec\", \"notes\" : \"Material Spec for chocolate chip cookies\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"choc_chip_001\" }, \"properties\" : [ { \"type\" : \"property_and_conditions\", \"property\": { \"type\" : \"property\", \"name\" : \"Cookie Composition\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"choc_chip_comp_01\" }, \"value\" : { \"type\" : \"nominal_composition\", \"quantities\" : { \"flour\" : 355, \"baking soda\" : 6, \"baking powder\" : 9, \"salt\" : 8, \"butter\": 225, \"granulated sugar\" : 205, \"brown sugar\" : 225, \"vanilla extract\" : 15, \"eggs\" : 50, \"chocolate chips\" : 395, \"chopped nuts\" : 225 } } }, \"conditions\": [] } ], \"process_spec\" : { \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"064148e6-1cce-4d89-bfde-7ecd0aa4632b\" } } Material Run # A particular instance of a material, e.g. a sample, ingot, or wafer. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"material_run\" name String Req. The name of the material run notes String None Some free-form notes about the material run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API spec Material Spec Req. The material spec of which this is a run process Process Run Req. The Process Run that produced this material measurements Set[ Measurement Run ] Empty characterizations of this Material Run sample_type experimental , production , or virtual , unknown unknown Context of how this material was made to be Constraints Same as Material Spec, but with the template inherited from the spec , i.e. spec.template . A Material Run along with its spec and process must form a \"square.\" That is, the spec's process and the process's spec must point to the same Process Spec. Field name Relationship Field Name process.spec = spec.process Example { \"type\" : \"material_run\", \"uids\" : { \"cookie_ids\" : \"choc_chip_001_run_006\" }, \"name\" : \"Chocolate Chip Cookie Run 006\", \"notes\" : \"Material Run for chocolate chip cookies\", \"sample_type\" : \"production\", \"spec\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\" : \"choc_chip_001\" }, \"process\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\": \"choc_chip_proc_001_run_006\" }, \"measurements\" : [ { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\" : \"choc_chip_001_hedonic_006\" } ] } Measurement Spec # An expectation for a measurement, indicating the parameters of and conditions under which to perform the measurement. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"measurement_spec\" name String Req. The name of the spec notes String None Some free-form notes about the spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Measurement Template None A template bounding the valid values for parameter and conditions of the measurement. parameters Set[ Parameters ] Empty Specified parameters for the measurement conditions Set[ Conditions ] Empty Specified conditions for the measurement Constraints All attributes sharing an Attribute Template with an attribute on the associated Object Template will be constrained by the (potentially tighter) bounds set in the template . Field name Relationship Field Name property names must be unique among property names condition names must be unique among condition names parameter names must be unique among parameter names property templates must be unique among the templates of properties parameter templates must be unique among the templates of parameters condition templates must be unique among the templates of conditions Example { \"type\" : \"measurement_spec\", \"uids\" : { \"cookie_ids\" : \"choc_chip_hedonic_spec\" }, \"name\" : \"Chocolate Chip Cookie Hedonic Index Measurement Spec\", \"notes\" : \"Measurement Specs for measuring the hedonic index of chocolate chip cookies\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"choc_chip_hedonic\" }, \"parameters\" : [ { \"type\" : \"parameter\", \"name\" : \"Cookie Quantity\", \"notes\" : \"You'll want to eat at least this many cookies for the hedonic index test\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"cookie_count\" }, \"value\" : { \"type\" : \"nominal_integer\", \"nominal\" : 7 } } ], \"conditions\" : [ { \"type\" : \"condition\", \"name\" : \"Cookie Temperature\", \"notes\" : \"Let them cool, or you'll burn your mouth and ruin the test.\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"cookie_eating_temp\" }, \"value\" : { \"type\" : \"nominal_real\", \"nominal\" : 320, \"units\" : \"kelvin\" } } ] } Measurement Run # A particular instance of a measurement. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"measurement_run\" name String Req. The name of the measurement run notes String None Some free-form notes about the measurement run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API source Source None provenance information for the measurement spec Measurement Spec Req. The measurement spec of which this is a run material Material Run Req. The material run being measured parameters Set[ Parameters ] Empty Measured parameters for the measurement conditions Set[ Conditions ] Empty Measured conditions for the measurement properties Set[ Properties ] Empty Measured properties for the measurement Constraints Field name Relationship Field Name property names must be unique among property names condition names must be unique among condition names parameter names must be unique among parameter names property templates must be unique among the templates of properties parameter templates must be unique among the templates of parameters condition templates must be unique among the templates of conditions Example { \"type\" : \"measurement_run\", \"uids\" : { \"cookie_ids\" : \"choc_chip_hedonic_run_006\" }, \"name\" : \"Chocolate Chip Hedonic Measurement\", \"notes\" : \"Rate the cookies on a scale from 9.9-10\", \"measurement_spec\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\" : \"choc_chip_hedonic_spec\" }, \"material_run\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\": \"choc_chip_001_run_006\" }, \"properties\" : [ { \"type\" : \"property\", \"name\" : \"Chocolate Chip Cookie Hedonic Index\", \"notes\" : \"delish\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"hedonic_index_prop\" }, \"value\" : { \"type\" : \"nominal_real\", \"nominal\" : 9.997, \"units\" : \"\" } } ], \"conditions\" : [ { \"type\" : \"condition\", \"name\" : \"Measured Cookie Temperature\", \"notes\" : \"used a thermopen\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"cookie_eating_temp\" }, \"value\" : { \"type\" : \"uniform_real\", \"lower_bound\" : \"318.15\", \"upper_bound\" : \"318.25\", \"units\" : \"kelvin\" } } ], \"parameters\" : [ { \"type\" : \"parameter\", \"name\" : \"Cookie Quantity\", \"notes\" : \"I kept going and lost count.\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"cookie_count\" }, \"value\" : { \"type\" : \"uniform_integer\", \"lower_bound\" : 7, \"upper_bound\" : 12 } } ] } Source # Provenance is the documented history of an Object. This includes information such as who performed a measurement, the literature source describing the design of a process, or the purveyor and catalog number for a purchased material. This type of information tends to have limited value for modeling and other analysis but is essential for verification and auditing. At present the only type of source supported is who performed a task and when they did so. Sources can be added to ProcessRun and MeasurementRun Objects only. Field name Value type Default Description type String Req. \"performed_source\" performed_by String None The person who performed the measurement performed_date String None The date the measurement was performed; ISO-8601 date-formatted string (YYYY-MM-DD or YYYY-MM-DDTHH:mm:SS) Example { \"type\": \"performed_source\", \"performed_by\": \"joe@abc.com\", \"performed_date\": \"2015-03-14T15:09:27\" }","title":"Objects"},{"location":"specification/objects/#process-spec","text":"An expectation of a process. Processes transform zero or more input materials into exactly one output material. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"process_spec\" name String Req. The name of the spec notes String None Some free-form notes about the spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Process Template None A template bounding the valid values for parameters and conditions on this process. parameters Set[ Parameters ] Empty Specified parameters for the process spec conditions Set[ Conditions ] Empty Specified conditions for the process spec ingredients Set[ Ingredient Spec ] Empty Ingredient Specs output_material Material Spec Req. Output Material Spec","title":"Process Spec"},{"location":"specification/objects/#process-run","text":"A particular instance of a process. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"process_run\" name String Req. The name of the process run notes String None Some free-form notes about the process run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API source Source None provenance information for the process spec Process Spec Req. Spec for this process parameters Set[ Parameters ] Empty Measured parameters for the process run conditions Set[ Conditions ] Empty Measured conditions for the process run ingredients Set[ Ingredient Run ] Empty Ingredient Runs output_material Material Run Req. Output Material Run","title":"Process Run"},{"location":"specification/objects/#ingredient-spec","text":"The intent for an ingredient, which annotates a material with information related to its usage in an individual process. Note that the name and labels for an Ingredient Spec are shared with all associated Ingredient Runs. These might be better thought of as the name of the role of a material in the process (e.g., binder) and not of the material itself (e.g., portland cement). Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"ingredient_spec\" name String Req. The name of the ingredient, unique within the process that contains it labels Set[String] Empty Additional labels on the ingredient for describing the type or role of the ingredient material Material Spec Req. Material that is this ingredient process Process Spec Req. Process that the ingredient is used in notes String Empty Some free-form notes about the spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API mass_fraction Real Value None The mass fraction of the ingredient in the process volume_fraction Real Value None The volume fraction of the ingredient in the process number_fraction Real Value None The number fraction (i.e., mole fraction) of the ingredient in the process absolute_quantity Real Value None The absolute quantity of the ingredient in the process Note that \"fraction of the ingredient\" refers to the amount of the ingredient divided by the total amount of material going into the process, not the fraction of the total amount of ingredient.material used in the process.","title":"Ingredient Spec"},{"location":"specification/objects/#ingredient-run","text":"A particular instance of an ingredient spec. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"ingredient_run\" material Material Run Req. Material that is this ingredient process Process Run Req. Process that the ingredient is used in notes String None Some free-form notes about the run. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API mass_fraction Real Value None The mass fraction of the ingredient in the process volume_fraction Real Value None The volume fraction of the ingredient in the process number_fraction Real Value None The number fraction of the ingredient in the process absolute_quantity Real Value None The absolute quantity of the ingredient in the process spec Ingredient Spec Req. The spec of which this is a run Note that \"fraction of the ingredient\" refers to the amount of the ingredient divided by the total amount of material going into the process, not the fraction of the total amount of ingredient.material used in the process.","title":"Ingredient Run"},{"location":"specification/objects/#material-spec","text":"The expectation for a material. Materials have exactly one producing process. Material specs may include expected properties, but do so via the PropertiesAndConditions compound attribute. In this way, material specs can associate an expected property value with the conditions under which it is expected. For example, if a material is purchased and its Safety Data Sheet quotes a normal boiling point of 54 C, a property is known even though there is never an explicit measurement of that property by a person in the lab. It could therefore be annotated with a Boiling Temperature of 54 C (property) at 1 atm (condition). Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"material_spec\" name String Req. The name of the spec notes String None Some free-form notes about the spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Material Template None A template bounding the valid values for properties of this material. properties Set[ PropertiesAndConditions ] Empty Expected properties for the material spec process Process Spec Req. The Process Spec that produces this material","title":"Material Spec"},{"location":"specification/objects/#material-run","text":"A particular instance of a material, e.g. a sample, ingot, or wafer. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"material_run\" name String Req. The name of the material run notes String None Some free-form notes about the material run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API spec Material Spec Req. The material spec of which this is a run process Process Run Req. The Process Run that produced this material measurements Set[ Measurement Run ] Empty characterizations of this Material Run sample_type experimental , production , or virtual , unknown unknown Context of how this material was made to be","title":"Material Run"},{"location":"specification/objects/#measurement-spec","text":"An expectation for a measurement, indicating the parameters of and conditions under which to perform the measurement. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"measurement_spec\" name String Req. The name of the spec notes String None Some free-form notes about the spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Measurement Template None A template bounding the valid values for parameter and conditions of the measurement. parameters Set[ Parameters ] Empty Specified parameters for the measurement conditions Set[ Conditions ] Empty Specified conditions for the measurement","title":"Measurement Spec"},{"location":"specification/objects/#measurement-run","text":"A particular instance of a measurement. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"measurement_run\" name String Req. The name of the measurement run notes String None Some free-form notes about the measurement run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API source Source None provenance information for the measurement spec Measurement Spec Req. The measurement spec of which this is a run material Material Run Req. The material run being measured parameters Set[ Parameters ] Empty Measured parameters for the measurement conditions Set[ Conditions ] Empty Measured conditions for the measurement properties Set[ Properties ] Empty Measured properties for the measurement","title":"Measurement Run"},{"location":"specification/objects/#source","text":"Provenance is the documented history of an Object. This includes information such as who performed a measurement, the literature source describing the design of a process, or the purveyor and catalog number for a purchased material. This type of information tends to have limited value for modeling and other analysis but is essential for verification and auditing. At present the only type of source supported is who performed a task and when they did so. Sources can be added to ProcessRun and MeasurementRun Objects only. Field name Value type Default Description type String Req. \"performed_source\" performed_by String None The person who performed the measurement performed_date String None The date the measurement was performed; ISO-8601 date-formatted string (YYYY-MM-DD or YYYY-MM-DDTHH:mm:SS)","title":"Source"},{"location":"specification/tags/","text":"Tags For any identifiers that are uniquely associated with an object, we have Alternative ID . However, there are a number of cases where an identifier spans multiple objects. A great example of this would be a Batch ID for multiple outputs of something that is conceptually the same process. Perhaps a user decides that they'd like to bake both a chocolate cake and a vanilla cake in the same oven at the same time. The specified temperatures and durations are similar enough that this should work well. They'd create two process runs - one outputting a chocolate cake material run, and one outputting a vanilla cake material run. But there is nothing recording the fact that both cakes were in the oven together. They can define a tag that would allow them to record this information with the id of their oven, and the date, \"Oven_14::2019-04-15\" and apply that tag to both of the process runs and/or material runs. Tags # Tags are a flexible way to store hierarchical information about your data, or to store identifiers that span many objects. Each tag is string valued, but can use :: as a delimiter define a hierarchy from broad to narrow. However, care should be taken to ensure that the first class in the hierarchy is sufficiently specific such that there is diversity in the first class (or prefix ) of hierarchical tags. This way, the prefix can be used as a partition key for distributing data in a database. Field name Value type Description tags Set[String] A set of strings Constraints Field name Relationship Field Name len( tags ) <= 100 len(a tag) <= 256, UTF-8 encoded Example { \"tags\" : [ \"product_13::batch_45\", \"kiln_37::2019-04-12\", \"Al203::powder::batch_24\", \"fresh powdah\" ] }","title":"Tags"},{"location":"specification/tags/#tags","text":"Tags are a flexible way to store hierarchical information about your data, or to store identifiers that span many objects. Each tag is string valued, but can use :: as a delimiter define a hierarchy from broad to narrow. However, care should be taken to ensure that the first class in the hierarchy is sufficiently specific such that there is diversity in the first class (or prefix ) of hierarchical tags. This way, the prefix can be used as a partition key for distributing data in a database. Field name Value type Description tags Set[String] A set of strings","title":"Tags"},{"location":"specification/unique-identifiers/","text":"Unique Identifiers There is a single top-level uids element on all Objects. This element is a map from scope to id with a maximum of 8 total elements. Citrine reserves one scope and will not allow a value to be set: \"ID\". This reserved element is referred to as the Citrine ID, and will always point to a version 4 random UUID generated by the Citrine Platform. The remaining elements of the map are referred to as \"alternative identifiers\" or \"customer identifiers\". The id component of customer identifiers need not be globally unique on its own, but the pair of ( scope , id ) must be unique. Equivalently, every alternative uid must be unique within its designated scope. Each scope , id pair can be associated with exactly one object. Scopes should be interpreted as case-insensitive, e.g. MyId and MYID refer to the same scope. Citrine ID # The unique identifier for all Objects on the platform Scope Value type Description ID String string representation of a random Version 4 UUID Constraints Field name Relationship Field Name len( id ) == 36 id parses to Version 4 Random UUID Example { \"uids\" : { \"id\" : \"f36099b9-2ca1-4ff7-afd2-dd226dc79e66\" } } Alternative IDs # A scope and identifier that, together, form an alternative unique identifier for an object platform-wide. Field name Value type Description uids Map[String, String] a map from scope to id Constraints Field name Relationship Field Name len( uids ) <= 8 len( scope ) <= 128, UTF-8 encoded len( id ) <= 512, UTF-8 encoded Example { \"uids\": { \"NIST-SRM\" : \"141e\" } } LinkByUID # Any nested object with a unique identifier can be replaced by a LinkByUID object. In general, the SDK for the data model implementation should handle translating nested structures into LinkByUID objects at write time - users of the SDK should only need to specify a LinkByUID object under very specific circumstances. Field name Value type Description type String \"link_by_uid\" scope String The scope of the unique identifier, e.g. \"ID\" for the Citrine ID id String The value of the identifier within that scope, e.g. a UUID4 for the Citrine ID Example { \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"8ee36a2e-66ce-4106-81c9-2b73cc0c6cb9\" } { \"type\" : \"link_by_uid\", \"scope\" : \"NIST-SRM\", \"id\" : \"141e\" }","title":"Unique Identifiers"},{"location":"specification/unique-identifiers/#citrine-id","text":"The unique identifier for all Objects on the platform Scope Value type Description ID String string representation of a random Version 4 UUID","title":"Citrine ID"},{"location":"specification/unique-identifiers/#alternative-ids","text":"A scope and identifier that, together, form an alternative unique identifier for an object platform-wide. Field name Value type Description uids Map[String, String] a map from scope to id","title":"Alternative IDs"},{"location":"specification/unique-identifiers/#linkbyuid","text":"Any nested object with a unique identifier can be replaced by a LinkByUID object. In general, the SDK for the data model implementation should handle translating nested structures into LinkByUID objects at write time - users of the SDK should only need to specify a LinkByUID object under very specific circumstances. Field name Value type Description type String \"link_by_uid\" scope String The scope of the unique identifier, e.g. \"ID\" for the Citrine ID id String The value of the identifier within that scope, e.g. a UUID4 for the Citrine ID","title":"LinkByUID"},{"location":"specification/value-types/","text":"Value Types Value is a generic term for the information contained in an attribute . A Value may be one of the following Value Types: Value Type Variant Description RealValue NominalReal NormalReal UniformReal A double value and a unit (e.g., 32F, 45 meters, 14 kg). Each variation provides a different mechanism for defining uncertainty. IntegerValue NominalInteger UniformInteger A whole integer value. Categorical NominalCategorical DiscreteCategorical Categorical values are distributions over the valid category names representing the probability of each category. For DiscreteCategorical, the values must sum to 1.0. Composition NominalComposition EmpiricalFormula A value containing the composition of the material as a a map from the names of the components to their numerical quantities. The quantities are not required to be expressed on a unit or fractional basis. Molecular Smiles Inchi Molecular structure using popular encoding schemes Many of these values represent probability distributions, e.g. normal and uniform distributions over continuous bounds or discrete distributions over categorical ones. Each of the Value Types is described below. Every field is required. Real Values # Two common distributions are supported: normal (i.e. Gaussian) and uniform. In cases when there is no distributional information, the \"nominal\" value type can be used to specify the expected value. Normal Real Value # Normally distributed value parameterized by a real-valued mean and standard deviation. A normal distribution is considered valid with a set of Real Bounds if the mean lies between the upper and lower bound; the width of the distribution is not considered. From a computational perspective, this means Normal Real Values are actually truncated Gaussians, though this is only significant for a distribution near the boundary. Field name Value type Description type String \"normal_real\" mean Number Mean of the distribution std Number Standard deviation of the normal distribution units String A String describing the units Constraints Field name Relationship Field Name std >= 0 Example { \"type\" : \"normal_real\", \"units\" : \"kelvin\", \"mean\": 350, \"std\": 1.03 } Uniform Real Value # A Uniform continuous distribution value, with inclusive lower and upper bounds. These are especially useful for expressing uncertainty when the number of digits is truncated. In order to be valid, the entirety of the distribution must fall within the bounds. Field name Value type Description type String \"uniform_real\" lower_bound Number Lower bound of the distribution upper_bound Number Upper bound of the distribution units String A String describing the units ##### Constraints Field name Relationship Field Name lower_bound <= upper_bound Example A value field read off a digital display with 3 decimal points. { \"type\" : \"uniform_real\", \"units\" : \"meter\", \"lower_bound\": 0.9995, \"upper_bound\": 1.0005 } Nominal Real Value # Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_real\" nominal Number A nominal value - not assumed to be exact units String A String describing the units Constraints None Example { \"type\" : \"nominal_real\", \"units\" : \"meter\", \"nominal\": 1.0 } Integer Values # Currently, there are two integer types: a uniform (i.e. range) distribution and a nominal (i.e. specified) value. Uniform Integer Value # A uniform integer distribution value, with inclusive lower and upper bounds. These are especially useful for expressing uncertainty when the number of digits is truncated. In order to be valid, the entirety of the distribution must fall within the bounds. Field name Value type Description type String \"uniform_integer\" lower_bound Integer Lower bound of the distribution upper_bound Integer Upper bound of the distribution Constraints Field name Relationship Field Name lower_bound <= upper_bound Example A value field read off a digital display with 3 decimal points. { \"type\" : \"uniform_integer\", \"lower_bound\": 246, \"upper_bound\": 255 } Nominal Integer Value # Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_integer\" nominal Integer A nominal value - not assumed to be exact Constraints None Example { \"type\" : \"nominal_integer\", \"nominal\": 42 } Categorical # Categorical values are distributions over the valid category names representing the probability of each category. These are different than mixtures; 60% water and 40% ethanol is not a categorical distribution. For those, see Composition . Currently, there are two categorical types: a discrete (i.e. enumerated) distribution and a nominal (i.e. specified) value. Discrete Categorical Value # Distribution of categories stored as a map from the string label to the probability Field name Value type Description type String \"discrete_categorical\" probabilities Map[String, Number] A map from string category names to their probability. Constraints Field name Relationship Field Name abs(sum(probabilities.values()) - 1.0) < 1.0e-9 each probability value >= 0 Example { \"type\":\"discrete_categorical\", \"probabilities\" : { \"red\" : 0.54, \"blue\" : 0.46 } } Nominal Categorical Value # Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_categorical\" nominal String The category of the value Constraints None Example { \"type\" : \"nominal_categorical\", \"nominal\" : \"red\" } Composition # A value representing the composition of the material as a set of component names and their respective quantities. The quantities are not required to be expressed on a unit or fractional basis. For example \"one part flour two parts sugar\" is acceptable. Nominal Composition # A composition represented as a map from the component name to the quantity. The quantities do not express an uncertainty, but also do not imply that there is absolute certainty in their values. Field name Value type Description type String \"nominal_composition\" quantities Map[String, Number] Map[String, Number] Constraints Field name Relationship Field Name each quantity value >= 0 Example { \"type\" : \"nominal_composition\", \"quantities\" : { \"water\" : 120, \"ethanol\" : 80 } } Empirical Formula # A composition represented as a chemical formula string. The order and grouping of the elements is ignored. Field name Value type Description type String \"empirical_formula\" formula String Chemical formula to be parsed as an empirical formula Example { \"type\" : \"empirical_formula\", \"formula\" : \"SiO2\" } Molecular Structure # Molecular structure types are used to define attributes that contain information about the structure and composition of a molecule. Given a molecular structure, one can infer the chemical formula, existence of functional groups, and local chemical environment of each atom in the molecule. Most commonly a molecular structure will refer to the entire material, but multiple molecular structures can be used to define fragments of a material, e.g. monomers of a polymer. We support two ways of representing a molecular structure: SMILES string InChI string SMILES Value A value containing a SMILES string . Field name Value type Description type String \"smiles\" smiles String A SMILES string Example { \"type\" : \"smiles\", \"smiles\" : \"c1(C=O)cc(OC)c(O)cc1\" } InChI Value A value containing an InChI string . Note: this is not the same as the InChI key. Field name Value type Description type String \"inchi\" inchi String An InChI string Example { \"type\" : \"inchi\", \"inchi\" : \"InChI=1/C8H8O3/c1-11-8-4-6(5-9)2-3-7(8)10/h2-5,10H,1H3\" }","title":"Value Types"},{"location":"specification/value-types/#real-values","text":"Two common distributions are supported: normal (i.e. Gaussian) and uniform. In cases when there is no distributional information, the \"nominal\" value type can be used to specify the expected value.","title":"Real Values"},{"location":"specification/value-types/#normal-real-value","text":"Normally distributed value parameterized by a real-valued mean and standard deviation. A normal distribution is considered valid with a set of Real Bounds if the mean lies between the upper and lower bound; the width of the distribution is not considered. From a computational perspective, this means Normal Real Values are actually truncated Gaussians, though this is only significant for a distribution near the boundary. Field name Value type Description type String \"normal_real\" mean Number Mean of the distribution std Number Standard deviation of the normal distribution units String A String describing the units","title":"Normal Real Value"},{"location":"specification/value-types/#uniform-real-value","text":"A Uniform continuous distribution value, with inclusive lower and upper bounds. These are especially useful for expressing uncertainty when the number of digits is truncated. In order to be valid, the entirety of the distribution must fall within the bounds. Field name Value type Description type String \"uniform_real\" lower_bound Number Lower bound of the distribution upper_bound Number Upper bound of the distribution units String A String describing the units ##### Constraints Field name Relationship Field Name lower_bound <= upper_bound","title":"Uniform Real Value"},{"location":"specification/value-types/#nominal-real-value","text":"Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_real\" nominal Number A nominal value - not assumed to be exact units String A String describing the units","title":"Nominal Real Value"},{"location":"specification/value-types/#integer-values","text":"Currently, there are two integer types: a uniform (i.e. range) distribution and a nominal (i.e. specified) value.","title":"Integer Values"},{"location":"specification/value-types/#uniform-integer-value","text":"A uniform integer distribution value, with inclusive lower and upper bounds. These are especially useful for expressing uncertainty when the number of digits is truncated. In order to be valid, the entirety of the distribution must fall within the bounds. Field name Value type Description type String \"uniform_integer\" lower_bound Integer Lower bound of the distribution upper_bound Integer Upper bound of the distribution","title":"Uniform Integer Value"},{"location":"specification/value-types/#nominal-integer-value","text":"Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_integer\" nominal Integer A nominal value - not assumed to be exact","title":"Nominal Integer Value"},{"location":"specification/value-types/#categorical","text":"Categorical values are distributions over the valid category names representing the probability of each category. These are different than mixtures; 60% water and 40% ethanol is not a categorical distribution. For those, see Composition . Currently, there are two categorical types: a discrete (i.e. enumerated) distribution and a nominal (i.e. specified) value.","title":"Categorical"},{"location":"specification/value-types/#discrete-categorical-value","text":"Distribution of categories stored as a map from the string label to the probability Field name Value type Description type String \"discrete_categorical\" probabilities Map[String, Number] A map from string category names to their probability.","title":"Discrete Categorical Value"},{"location":"specification/value-types/#nominal-categorical-value","text":"Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_categorical\" nominal String The category of the value","title":"Nominal Categorical Value"},{"location":"specification/value-types/#composition","text":"A value representing the composition of the material as a set of component names and their respective quantities. The quantities are not required to be expressed on a unit or fractional basis. For example \"one part flour two parts sugar\" is acceptable.","title":"Composition"},{"location":"specification/value-types/#nominal-composition","text":"A composition represented as a map from the component name to the quantity. The quantities do not express an uncertainty, but also do not imply that there is absolute certainty in their values. Field name Value type Description type String \"nominal_composition\" quantities Map[String, Number] Map[String, Number]","title":"Nominal Composition"},{"location":"specification/value-types/#empirical-formula","text":"A composition represented as a chemical formula string. The order and grouping of the elements is ignored. Field name Value type Description type String \"empirical_formula\" formula String Chemical formula to be parsed as an empirical formula","title":"Empirical Formula"},{"location":"specification/value-types/#molecular-structure","text":"Molecular structure types are used to define attributes that contain information about the structure and composition of a molecule. Given a molecular structure, one can infer the chemical formula, existence of functional groups, and local chemical environment of each atom in the molecule. Most commonly a molecular structure will refer to the entire material, but multiple molecular structures can be used to define fragments of a material, e.g. monomers of a polymer. We support two ways of representing a molecular structure: SMILES string InChI string","title":"Molecular Structure"}]}