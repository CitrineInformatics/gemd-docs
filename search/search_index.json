{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GEMD Documentation \u00b6 GEMD stands for Graphical Expression of Materials Data. It's an open-source format initially developed by Citrine Informatics . A version of it is used in their AI platform for materials and chemicals, but as described here it can be used independently. The model links together materials, the processes that produced them, and the measurements that characterize them. This facilitates the backwards traversal from (i) a measurement to (ii) the material on which it was performed to (iii) the process by which it was produced to (iv) the materials which were used in that process. It generalizes and matures preparation and subSystems objects within the PIF ( Physical Information File ). Additionally, the model makes a first-class distinction between intent and realization , captured by Spec and Run objects, respectively. A single intent Spec can be realized into multiple Run objects. This generalizes and matures the ideal concept from the PIF's Composition and Quantity objects. The model contains a new type of object: the Measurement Run . Measurements capture discrete measurement activity, including the parameters and conditions associated with a set of measured properties. This many-to-many relationship between properties, conditions, and parameters resolves a fundamental ambiguity present in the PIF -- which properties were measured at the same time under the same conditions? Specification of the NextGen Data format \u00b6 The format is described in the following subsections: Value Types Attributes Attribute Templates Object Templates Objects Unique Identifiers Tags File Links Getting help \u00b6 Check out our FAQ !","title":"GEMD Documentation"},{"location":"#gemd-documentation","text":"GEMD stands for Graphical Expression of Materials Data. It's an open-source format initially developed by Citrine Informatics . A version of it is used in their AI platform for materials and chemicals, but as described here it can be used independently. The model links together materials, the processes that produced them, and the measurements that characterize them. This facilitates the backwards traversal from (i) a measurement to (ii) the material on which it was performed to (iii) the process by which it was produced to (iv) the materials which were used in that process. It generalizes and matures preparation and subSystems objects within the PIF ( Physical Information File ). Additionally, the model makes a first-class distinction between intent and realization , captured by Spec and Run objects, respectively. A single intent Spec can be realized into multiple Run objects. This generalizes and matures the ideal concept from the PIF's Composition and Quantity objects. The model contains a new type of object: the Measurement Run . Measurements capture discrete measurement activity, including the parameters and conditions associated with a set of measured properties. This many-to-many relationship between properties, conditions, and parameters resolves a fundamental ambiguity present in the PIF -- which properties were measured at the same time under the same conditions?","title":"GEMD Documentation"},{"location":"#specification-of-the-nextgen-data-format","text":"The format is described in the following subsections: Value Types Attributes Attribute Templates Object Templates Objects Unique Identifiers Tags File Links","title":"Specification of the NextGen Data format"},{"location":"#getting-help","text":"Check out our FAQ !","title":"Getting help"},{"location":"faq/","text":"FAQ \u00b6 It's not you; it's us. GEMD is not a simple representation, and we frequently get questions about how to use it to represent certain kinds of data. This page attempts to answer some of those questions. How do you pronounce GEMD? \u00b6 This has been a matter of some debate. Both /jemd/ and /jem-dee/ are in common use. I'm following the documentation, but still having validation problems when using the Citrine Platform. \u00b6 The implementation of GEMD on the current Citrine Platform is not 100% as described here. Check out Known Limitations or contact your Citrine representative for help. Where do I store statistics about my measurements? \u00b6 Let's say that you have data for the same kind of measurement being repeated multiple times. For example, you take a sample from your material, subdivide it 8 times, and perform the same measurement on each of those 8 sub-samples. The measurement that you are performing can be represented by a single MeasurementSpec and each of those 8 sub-samples as its own MeasurementRun associated with that spec. Each MeasurementRun is associated with the MatererialRun representing the material that you sampled and sub-divided. For each property in the MeasurementRun objects, you may want to compute some statistics of the 8-sample distribution, e.g., the mean and the standard deviation of each property and/or its minimum and maximum values. In the future, these statistics will be automatically computed on the Citrine Platform. For now, you can compute them yourself and record them in another MeasurementRun object distinct from the 8 samples. If there are multiple properties and/or multiple statistics, they should all go in the same MeasurementRun . The statistics should be Property attributes with their origin field set to computed . How do I represent repeated applications of the same process? \u00b6 Consider a situation in which a process is repeatedly applied to a material, but does not substantially change the material, e,g., repeated application of heat-treatment to harden a ceramic or multiple coats of paint. Because material histories are chronological, each application must be a new process and must produce a new output material. However, the materials/processes may reference the same templates if the same attributes are relevant for each iteration. It is strongly recommended that such processes contain an attribute describing what order that process was performed in (e.g., heat-treatment number 1, 2, 3, etc.). This additional attribute will allow for disambiguation between these linear processes. The additional attribute should have an Attribute Template , but there is no requirement for it to be included in the Object Template as well. How do I represent repeated uses of the same material? \u00b6 It is perfectly fine for the same material to be used in multiple processes throughout a material history, but a new ingredient must be created for each use. Ingredients annotate the use of a specific material in a specific process, recording how much was used and labeling the role of the material. Process templates should be used to describe what types of ingredients are expected in a process. The same material can even be used multiple times in one process. Consider the following example: a thin film is created by thermally evaporating three materials in succession onto a substrate. The thermal evaporation process template specifies the allowed names as \"layer 1,\" \"layer 2,\" and \"layer 3.\" We have several materials to choose from for the three layers, but in one instance we wish to evaporate a layer of material \"A,\" then a layer of \"B,\" then a final layer of \"A.\" We create a Process Spec linked to the thermal evaporation process template and create three Ingredient Specs, each of which point to the Process Spec as their process . One ingredient points to \"A\" as its material and has layer 1 as its name. One points to \"B\" as its material and has layer 2 as its name. And the final Ingredient Spec also points to \"A\" as its material but is differentiated because it has layer 3 as its name. What is the difference between description and notes ? \u00b6 description is a field on both Attribute Templates and Object Templates . It is used to describe the type of data that a template is intended to constrain--the documentation of its intended use. We strongly encourage documenting all templates, given both how important they are in constraining data and communicating structure to analysis algorithms, and that a template is likely to be reused by multiple users. notes are associated with Attributes and Objects . This is a place to put pieces of information that may be important to understanding this particular piece of data but do not naturally fit in the other fields. This might include an annotation about something unusual about this particular sample. Notes normally contain information that is useful for a human but would not be useful in training a machine learning model. I found a reference to something called \"taurus\" - what is that? \u00b6 \"Taurus\" was the codename for GEMD when we first started work. We're in the process of migrating everything over to GEMD, but names can be surprisingly persistent.","title":"FAQ"},{"location":"faq/#faq","text":"It's not you; it's us. GEMD is not a simple representation, and we frequently get questions about how to use it to represent certain kinds of data. This page attempts to answer some of those questions.","title":"FAQ"},{"location":"faq/#how-do-you-pronounce-gemd","text":"This has been a matter of some debate. Both /jemd/ and /jem-dee/ are in common use.","title":"How do you pronounce GEMD?"},{"location":"faq/#im-following-the-documentation-but-still-having-validation-problems-when-using-the-citrine-platform","text":"The implementation of GEMD on the current Citrine Platform is not 100% as described here. Check out Known Limitations or contact your Citrine representative for help.","title":"I'm following the documentation, but still having validation problems when using the Citrine Platform."},{"location":"faq/#where-do-i-store-statistics-about-my-measurements","text":"Let's say that you have data for the same kind of measurement being repeated multiple times. For example, you take a sample from your material, subdivide it 8 times, and perform the same measurement on each of those 8 sub-samples. The measurement that you are performing can be represented by a single MeasurementSpec and each of those 8 sub-samples as its own MeasurementRun associated with that spec. Each MeasurementRun is associated with the MatererialRun representing the material that you sampled and sub-divided. For each property in the MeasurementRun objects, you may want to compute some statistics of the 8-sample distribution, e.g., the mean and the standard deviation of each property and/or its minimum and maximum values. In the future, these statistics will be automatically computed on the Citrine Platform. For now, you can compute them yourself and record them in another MeasurementRun object distinct from the 8 samples. If there are multiple properties and/or multiple statistics, they should all go in the same MeasurementRun . The statistics should be Property attributes with their origin field set to computed .","title":"Where do I store statistics about my measurements?"},{"location":"faq/#how-do-i-represent-repeated-applications-of-the-same-process","text":"Consider a situation in which a process is repeatedly applied to a material, but does not substantially change the material, e,g., repeated application of heat-treatment to harden a ceramic or multiple coats of paint. Because material histories are chronological, each application must be a new process and must produce a new output material. However, the materials/processes may reference the same templates if the same attributes are relevant for each iteration. It is strongly recommended that such processes contain an attribute describing what order that process was performed in (e.g., heat-treatment number 1, 2, 3, etc.). This additional attribute will allow for disambiguation between these linear processes. The additional attribute should have an Attribute Template , but there is no requirement for it to be included in the Object Template as well.","title":"How do I represent repeated applications of the same process?"},{"location":"faq/#how-do-i-represent-repeated-uses-of-the-same-material","text":"It is perfectly fine for the same material to be used in multiple processes throughout a material history, but a new ingredient must be created for each use. Ingredients annotate the use of a specific material in a specific process, recording how much was used and labeling the role of the material. Process templates should be used to describe what types of ingredients are expected in a process. The same material can even be used multiple times in one process. Consider the following example: a thin film is created by thermally evaporating three materials in succession onto a substrate. The thermal evaporation process template specifies the allowed names as \"layer 1,\" \"layer 2,\" and \"layer 3.\" We have several materials to choose from for the three layers, but in one instance we wish to evaporate a layer of material \"A,\" then a layer of \"B,\" then a final layer of \"A.\" We create a Process Spec linked to the thermal evaporation process template and create three Ingredient Specs, each of which point to the Process Spec as their process . One ingredient points to \"A\" as its material and has layer 1 as its name. One points to \"B\" as its material and has layer 2 as its name. And the final Ingredient Spec also points to \"A\" as its material but is differentiated because it has layer 3 as its name.","title":"How do I represent repeated uses of the same material?"},{"location":"faq/#what-is-the-difference-between-description-and-notes","text":"description is a field on both Attribute Templates and Object Templates . It is used to describe the type of data that a template is intended to constrain--the documentation of its intended use. We strongly encourage documenting all templates, given both how important they are in constraining data and communicating structure to analysis algorithms, and that a template is likely to be reused by multiple users. notes are associated with Attributes and Objects . This is a place to put pieces of information that may be important to understanding this particular piece of data but do not naturally fit in the other fields. This might include an annotation about something unusual about this particular sample. Notes normally contain information that is useful for a human but would not be useful in training a machine learning model.","title":"What is the difference between description and notes?"},{"location":"faq/#i-found-a-reference-to-something-called-taurus-what-is-that","text":"\"Taurus\" was the codename for GEMD when we first started work. We're in the process of migrating everything over to GEMD, but names can be surprisingly persistent.","title":"I found a reference to something called \"taurus\" - what is that?"},{"location":"glossary/","text":"Glossary \u00b6 Attribute \u00b6 A characteristic of a material, process, or measurement. Attributes can be a GEMD property, condition, or parameter and contain a value. Attribute Template \u00b6 Attribute templates define a domain concept (e.g. density, yield strength), and include bounds to define acceptable values for a given attribute. Bounds \u00b6 Bounds are used in object and attribute templates. An attribute template will have the widest bounds, and an object template can restrict them. For example, the temperatures in casting will always be higher than the temperatures for annealing. Each value type (e.g., real, categorical) has a corresponding type of bounds. Categorical Bounds \u00b6 Bounds that are defined by a list of categories. Condition Attribute \u00b6 Environmental variables (typically measured) that may affect a process or measurement, such as temperature or pressure. Data Object \u00b6 GEMD materials, processes, measurements, and ingredients. Data objects along with attributes are linked to form a complete description of a final material and how it was created. GEMD \u00b6 Graphical Expression of Materials Data, an open source format for storing materials data. Ingredient Object \u00b6 A data object that annotates a material with information related to its usage in a process. Ingredient objects are used define how much of a material is used in a new process. Note that 'ingredient' and 'material' object definitions are not interchangeable. Material Object \u00b6 GEMD data object that describes a physical substance that is generated by a process and is characterized by its properties. GEMD does not allow material objects to exist in isolation, since fully describing a material data point requires, at minimum, identifying how the material was procured. Material Run \u00b6 An actual instance of a material. Material Spec \u00b6 Material spec objects are used to integrate information from external references, typically a data sheet. Reference information is optionally encoded via PropertyAndCondition attributes. Material Template \u00b6 Define how to validate any PropertyAndConditions attributes, if they exist on a linked material spec. Measurement Object \u00b6 A data object used to describe an operation that measures or characterizes properties of a material. Measurement Run \u00b6 A recorded measurement for a specific material run object. Measurement Spec \u00b6 Defines the experimental design or standard operating procedure for a measurement, including any parameters and conditions. Measurement Template \u00b6 Defines which conditions, parameters and properties are expected for a class of experimental measurements. Nominal Real Value \u00b6 A value type in which the value is recorded as a specific number with a unit, with no information about the uncertainty of that number. Object Template \u00b6 Object Templates define a domain concept for a process, material or measurement. Object templates compose bounds from attribute templates into constraints that define valid ranges. Parameter Attribute \u00b6 Describes the settings of a tool in a process or measurement object. Parameters are non-environmental variables (typically specified and controlled) that may affect a process or measurement. PIF \u00b6 Portable Information Format, a precursor to GEMD that is no longer in use. Process Object \u00b6 GEMD data object that describes an operation to generate an output material from inputs. Process Run \u00b6 A recorded run of a process, which may include parameters that are controlled and/or measured. Process Spec \u00b6 Defines the intent for how a process should work, including any expected parameters and conditions. Process Template \u00b6 Process templates are used to define constraints for the names and labels of ingredients. They may link conditions and parameters. Property Attribute \u00b6 Describes a measured or calculated property of a material object. PropertyAndConditions Attribute \u00b6 Known (unmeasured) properties of a Material Spec, with specified conditions. These usually come from a technical spec sheet or other external reference. Real Bounds \u00b6 Bounds defined by a range of finite real values and a unit. State \u00b6 Template, spec and run. Data objects are created in a state, representing generalization (template), intent (spec), and actual result (run). Tag \u00b6 Tags are used to categorize object templates. Uniform Real Value \u00b6 A value type in which the value is recorded as a range, with a lower bound and an upper bound, to represent the uncertainty of the measurement.","title":"Glossary"},{"location":"glossary/#glossary","text":"","title":"Glossary"},{"location":"glossary/#attribute","text":"A characteristic of a material, process, or measurement. Attributes can be a GEMD property, condition, or parameter and contain a value.","title":"Attribute"},{"location":"glossary/#attribute-template","text":"Attribute templates define a domain concept (e.g. density, yield strength), and include bounds to define acceptable values for a given attribute.","title":"Attribute Template"},{"location":"glossary/#bounds","text":"Bounds are used in object and attribute templates. An attribute template will have the widest bounds, and an object template can restrict them. For example, the temperatures in casting will always be higher than the temperatures for annealing. Each value type (e.g., real, categorical) has a corresponding type of bounds.","title":"Bounds"},{"location":"glossary/#categorical-bounds","text":"Bounds that are defined by a list of categories.","title":"Categorical Bounds"},{"location":"glossary/#condition-attribute","text":"Environmental variables (typically measured) that may affect a process or measurement, such as temperature or pressure.","title":"Condition Attribute"},{"location":"glossary/#data-object","text":"GEMD materials, processes, measurements, and ingredients. Data objects along with attributes are linked to form a complete description of a final material and how it was created.","title":"Data Object"},{"location":"glossary/#gemd","text":"Graphical Expression of Materials Data, an open source format for storing materials data.","title":"GEMD"},{"location":"glossary/#ingredient-object","text":"A data object that annotates a material with information related to its usage in a process. Ingredient objects are used define how much of a material is used in a new process. Note that 'ingredient' and 'material' object definitions are not interchangeable.","title":"Ingredient Object"},{"location":"glossary/#material-object","text":"GEMD data object that describes a physical substance that is generated by a process and is characterized by its properties. GEMD does not allow material objects to exist in isolation, since fully describing a material data point requires, at minimum, identifying how the material was procured.","title":"Material Object"},{"location":"glossary/#material-run","text":"An actual instance of a material.","title":"Material Run"},{"location":"glossary/#material-spec","text":"Material spec objects are used to integrate information from external references, typically a data sheet. Reference information is optionally encoded via PropertyAndCondition attributes.","title":"Material Spec"},{"location":"glossary/#material-template","text":"Define how to validate any PropertyAndConditions attributes, if they exist on a linked material spec.","title":"Material Template"},{"location":"glossary/#measurement-object","text":"A data object used to describe an operation that measures or characterizes properties of a material.","title":"Measurement Object"},{"location":"glossary/#measurement-run","text":"A recorded measurement for a specific material run object.","title":"Measurement Run"},{"location":"glossary/#measurement-spec","text":"Defines the experimental design or standard operating procedure for a measurement, including any parameters and conditions.","title":"Measurement Spec"},{"location":"glossary/#measurement-template","text":"Defines which conditions, parameters and properties are expected for a class of experimental measurements.","title":"Measurement Template"},{"location":"glossary/#nominal-real-value","text":"A value type in which the value is recorded as a specific number with a unit, with no information about the uncertainty of that number.","title":"Nominal Real Value"},{"location":"glossary/#object-template","text":"Object Templates define a domain concept for a process, material or measurement. Object templates compose bounds from attribute templates into constraints that define valid ranges.","title":"Object Template"},{"location":"glossary/#parameter-attribute","text":"Describes the settings of a tool in a process or measurement object. Parameters are non-environmental variables (typically specified and controlled) that may affect a process or measurement.","title":"Parameter Attribute"},{"location":"glossary/#pif","text":"Portable Information Format, a precursor to GEMD that is no longer in use.","title":"PIF"},{"location":"glossary/#process-object","text":"GEMD data object that describes an operation to generate an output material from inputs.","title":"Process Object"},{"location":"glossary/#process-run","text":"A recorded run of a process, which may include parameters that are controlled and/or measured.","title":"Process Run"},{"location":"glossary/#process-spec","text":"Defines the intent for how a process should work, including any expected parameters and conditions.","title":"Process Spec"},{"location":"glossary/#process-template","text":"Process templates are used to define constraints for the names and labels of ingredients. They may link conditions and parameters.","title":"Process Template"},{"location":"glossary/#property-attribute","text":"Describes a measured or calculated property of a material object.","title":"Property Attribute"},{"location":"glossary/#propertyandconditions-attribute","text":"Known (unmeasured) properties of a Material Spec, with specified conditions. These usually come from a technical spec sheet or other external reference.","title":"PropertyAndConditions Attribute"},{"location":"glossary/#real-bounds","text":"Bounds defined by a range of finite real values and a unit.","title":"Real Bounds"},{"location":"glossary/#state","text":"Template, spec and run. Data objects are created in a state, representing generalization (template), intent (spec), and actual result (run).","title":"State"},{"location":"glossary/#tag","text":"Tags are used to categorize object templates.","title":"Tag"},{"location":"glossary/#uniform-real-value","text":"A value type in which the value is recorded as a range, with a lower bound and an upper bound, to represent the uncertainty of the measurement.","title":"Uniform Real Value"},{"location":"high-level-overview/","text":"High Level Overview \u00b6 How is data stored \u00b6 GEMD stands for Graphical Expression of Materials Data. It's an open source format initially developed by the fine folks at Citrine Informatics. GEMD stores data via interconnected Data Objects, representing Specs and Runs of Materials, Processing steps, Measurements, and Ingredient information. This format is graphical rather than tabular. It will support a JSON-based serialization, like the PIF , but with links as references rather than nested objects (i.e., subsystems). Conversely, there are many new ideas that exist in GEMD that are not captured by the PIF, including: Process history and process order, including the input materials to process steps Conditions that are shared between properties Specified vs actual values Ingredient information of input materials of a process Don't worry if that seems quite complicated right now. The details are broken out in the coming sections. How are Data Objects defined? \u00b6 A picture is worth a thousand words: There are four categories of Data Objects in GEMD: Materials, Processes, Measurements, and Ingredients. These represent real world objects in the development of materials. The four categories of Data Objects can only be linked in specific ways; for example, a Process Object can only be linked to one or many Material Objects as its input (more details are explained in Table1). Each Object can be represented in three different states. These states are defined below. They are Template, Spec, and Run. Note, Ingredient Objects cannot be represented in the Template state. Material Object describes a material by a name used in an organization and optional notes to describe it. Measurement Object describes an operation used to measure or characterize one or more properties of a material and the parameters and conditions for that operation. Process Object describes an operation that generates an output material from one or more material inputs. Ingredient Object annotates a material with information related to its usage in a process including name (label on the ingredient that is unique within the process that contains it) and labels (additional labels on the ingredient). Object Examples Linked Objects State Possible Attributes Material Glass, H2O n/a Template Properties ^ ^ input: Process (1); Measurement (0 or many) Spec Properties and Conditions ^ ^ ^ Run none Process Gas pressure sintering, Binder burnout n/a Template Parameters and Conditions ^ ^ input: Ingredient (0 or many); output: Material (1) Spec Parameters and Conditions ^ ^ ^ Run Parameters and Conditions Measurement 3 point bend, combustion analysis n/a Template Properties, Parameters, and Conditions ^ ^ Material (1) Spec Parameters, and Conditions ^ ^ ^ Run Properties, Parameters, and Conditions Ingredient 80wt%, 20lbs, solute Material (1) Spec n/a ^ ^ ^ Run n/a Table1: Shows the relation of Objects to other Objects and Attributes possible in each state. Figure1: A graphical depiction of the relationship between core objects in a simple material history. How are Attributes defined? \u00b6 Each Data Object (except Ingredient Objects) can contain Attributes that describe it. There are three different categories of Attributes: Properties, Parameters, and Conditions. Attributes contain structured materials data that is representative of an Data Object. For example, a Process Object can have Parameters and Conditions as such: \u201csinter at 2400 K for 6 hours in kiln 14\u201d. Property Attribute describes a property that is measured or calculated, they are aspects of a material (e.g., \u201cthe hardness of the sample\u201d). Parameter Attribute describes the settings of a tool that are set by the user for a specific purpose (e.g., \u201cthe size of the indenter\u201d or \u201cthe grid spacing in a simulation\u201d). Condition Attribute describes the aspects of the environment during a process or measurement (e.g., \u201cthe temperature of the environment during measurement\u201d). Each Attribute has specified fields that are required or optional as defined in Table3 and Table6 below. How are States defined? \u00b6 There are 3 main states in which Data Objects exist: Templates, Spec, and Run. GEMD distinguishes between the generalization of what might be done (Template), the intent to do something (Spec), and the actual result of doing it (Run). As an example, one can have a Template for a Process Object defined as \u201csinter at {temperature} for {time} in kiln {id}\u201d. This would be the Template used for a Spec of a kiln process used in the production of alumina. The Spec of the Process object might be \u201csinter at 2400 K for 6 hours in kiln 14\u201d. The Process Run object would be what really happened when the process was conducted. For example, someone may have run the kiln and it ran at 2395 K. The Run of the Process object would be \u201csinter at 2395 K for 5.75 hours in kiln 14\u201d. All Data Objects (and all the Attributes that describe those Data Objects) in any State have specified fields that are required or optional. Table2 goes into further detail about the possible fields in all Data Objects and Attributes. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one Table2: Defines the possible fields in all Data Objects and Attributes in all states. Templates \u00b6 Templates are generalizations of Data Objects used to standardize data in GEMD. Templates are used at write time to validate data and at read time to associate groups of information together. Each Spec and Run Object or Attribute (excluding Ingredient Objects and Metadata Attributes) requires a linked Template to support this read and write time association and validation respectively. Attribute Templates \u00b6 An Attribute Template specifies the bounds that are acceptable for an Attribute. For example, an Attribute Template could specify a Real value bounded between -3 and +17, or it could define a Categorical bound with the following allowed categories: \"salt\", \"not salt\". The values of an Attribute with an Attribute Template must conform to the bounds specified by the Template. If the value is not compatible with the Template (e.g., if the Template specifies that the value must be in the range [0, 1] but the value is 2), an error is thrown. Table3 below defines the possible fields in all Attributes in the Template state. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one description Optional one bounds Required one Table3 : Shows the fields available for Attributes in the Template state. The scope defines to which category of Attribute (Property, Parameter, or Condition) the Attribute Template applies. Object Templates \u00b6 Object Templates are collections of Attribute Templates that together constrain the values of a Data Object's associated Attributes to valid ranges, and provide a common structure for describing similar Data Objects. Object Templates are useful for validating that all Data Objects being written or generated by a script are consistent and valid. In the future, Object Templates could be used to generate data input forms or similar interfaces. Table4 below defines the possible fields in all Data Objects in the Template state. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one description Optional one Table4 : Shows the fields available for each category of Data Object in the Template state. All Object Templates can also have additional Attribute Bounds set on defined Attributes. These are additional bounds that can be applied to Attributes associated with that Data Object. For example, consider there exists a Condition Attribute Template called \"Oven Temperature\" that is defined from 0 to 10,000 Kelvin and a Process Object Template that includes the \"Oven Temperature\" Condition Template. Along with the Condition Template \u201cOven Temperature\u201d, the Process Template can include additional Attribute bounds and restrict the values that can be applied to that Condition between 300 and 600 Kelvin. That second restriction is represented by a second bound paired with the Condition Template in the Process Object Template. Table5 below identifies all the possible Attributes that each Data Object can contain in the Template state. Object Template Property Template Parameter Template Condition Template Material Template yes no no Process Template no yes yes Measurement Template yes yes yes Table5 : Shows which Attributes can be linked to each Data Object in the Template state. Specs and Runs \u00b6 Specs define the intent to do something, usually formalized in the format of an experiment request, the intention of an experiment, or the definition of a property. For example, the normal boiling point of pure water is 99.61 C, a spec. Runs describe how a material, process, or measurement were actually performed, defined, or evaluated and the end results of that evaluation. For example, a sample of water boiled at 101 C, a run. Attribute in Specs and Runs \u00b6 Each Attribute has specified fields that are required or optional for both Spec or Run state. Table6 goes into further detail about the possible fields. Table6 represents the Attributes in diagram. Field Required/Optional Quantity Possible name Required one value Required one notes Optional one origin Required one template Optional one file_links Optional many Table6 : Shows the fields available for Attributes in the Spec and Run context. All attributes must specify the origin of their data as one of: Specified: it is the intention to have this value. Measured: this was directly measured during the Process or Measurement Run. Computed: this was calculated based on other measured or derived properties. Predicted: this was calculated based on a model, e.g., machine learning or simulation. Summary: this was calculated based on a set of the same property at a finer level of granularity (aggregation of data). Unknown: the origin is not known, typically when migrating legacy data. A value is a complex type that may contain both central (i.e., expected) and distributional (i.e., uncertainty) information. It also includes units for real (i.e., continuous) values. Data Object Specs and Runs \u00b6 Object Specs may have an associated Object Template that bounds the valid units and values of the Attributes on the Spec. With the linking of Specs to Runs, Runs inherit associated Templates through Specs. For example, Process Runs associated with a Process Spec inherit the Template associated with the Spec, and their Attributes are thus also constrained by the Template. Many Specs can reference the same Object Template. Each Spec can be associated with at most one Object Template (for now). Many Runs can reference the same Spec. Each Run must be associated with exactly one Spec. As Object Specs define the intent to do something, they are more limited in possible fields than Runs. Table7 represents what additional fields are required or optional for Object Specs. Field Required/Optional Quantity Possible Spec or Run uids Optional many both tags Optional many both name Required one both notes Optional one both file_links Optional many both template Optional one Spec spec Required one Run Table7 : Shows the fields available for Material, Measurement, and Process Objects in the Spec and Run contexts. Ingredient Objects are treated a little differently from the other Objects in GEMD because they are mainly used to annotate a Material with information related to its usage in a Process. Note that constraints on name and labels follow from the allowed_names and allowed_labels fields of the Process Template. Table8 below identifies all the fields available in Ingredient Objects for both Specs and Runs. Field Required/Optional Quantity Possible In Spec or Run uids Optional many both tags Optional many both notes Optional one both file_links Optional many both name Optional one Spec labels Optional many Spec material Required one both (with material object from respective state) mass_fraction Optional one both volume_fraction Optional one both number_fraction Optional one both absolute_quantity Optional one both spec Required one Run Table8 : Shows the fields available for Ingredient Objects in the Spec and Run context.","title":"High Level Overview"},{"location":"high-level-overview/#high-level-overview","text":"","title":"High Level Overview"},{"location":"high-level-overview/#how-is-data-stored","text":"GEMD stands for Graphical Expression of Materials Data. It's an open source format initially developed by the fine folks at Citrine Informatics. GEMD stores data via interconnected Data Objects, representing Specs and Runs of Materials, Processing steps, Measurements, and Ingredient information. This format is graphical rather than tabular. It will support a JSON-based serialization, like the PIF , but with links as references rather than nested objects (i.e., subsystems). Conversely, there are many new ideas that exist in GEMD that are not captured by the PIF, including: Process history and process order, including the input materials to process steps Conditions that are shared between properties Specified vs actual values Ingredient information of input materials of a process Don't worry if that seems quite complicated right now. The details are broken out in the coming sections.","title":"How is data stored"},{"location":"high-level-overview/#how-are-data-objects-defined","text":"A picture is worth a thousand words: There are four categories of Data Objects in GEMD: Materials, Processes, Measurements, and Ingredients. These represent real world objects in the development of materials. The four categories of Data Objects can only be linked in specific ways; for example, a Process Object can only be linked to one or many Material Objects as its input (more details are explained in Table1). Each Object can be represented in three different states. These states are defined below. They are Template, Spec, and Run. Note, Ingredient Objects cannot be represented in the Template state. Material Object describes a material by a name used in an organization and optional notes to describe it. Measurement Object describes an operation used to measure or characterize one or more properties of a material and the parameters and conditions for that operation. Process Object describes an operation that generates an output material from one or more material inputs. Ingredient Object annotates a material with information related to its usage in a process including name (label on the ingredient that is unique within the process that contains it) and labels (additional labels on the ingredient). Object Examples Linked Objects State Possible Attributes Material Glass, H2O n/a Template Properties ^ ^ input: Process (1); Measurement (0 or many) Spec Properties and Conditions ^ ^ ^ Run none Process Gas pressure sintering, Binder burnout n/a Template Parameters and Conditions ^ ^ input: Ingredient (0 or many); output: Material (1) Spec Parameters and Conditions ^ ^ ^ Run Parameters and Conditions Measurement 3 point bend, combustion analysis n/a Template Properties, Parameters, and Conditions ^ ^ Material (1) Spec Parameters, and Conditions ^ ^ ^ Run Properties, Parameters, and Conditions Ingredient 80wt%, 20lbs, solute Material (1) Spec n/a ^ ^ ^ Run n/a Table1: Shows the relation of Objects to other Objects and Attributes possible in each state. Figure1: A graphical depiction of the relationship between core objects in a simple material history.","title":"How are Data Objects defined?"},{"location":"high-level-overview/#how-are-attributes-defined","text":"Each Data Object (except Ingredient Objects) can contain Attributes that describe it. There are three different categories of Attributes: Properties, Parameters, and Conditions. Attributes contain structured materials data that is representative of an Data Object. For example, a Process Object can have Parameters and Conditions as such: \u201csinter at 2400 K for 6 hours in kiln 14\u201d. Property Attribute describes a property that is measured or calculated, they are aspects of a material (e.g., \u201cthe hardness of the sample\u201d). Parameter Attribute describes the settings of a tool that are set by the user for a specific purpose (e.g., \u201cthe size of the indenter\u201d or \u201cthe grid spacing in a simulation\u201d). Condition Attribute describes the aspects of the environment during a process or measurement (e.g., \u201cthe temperature of the environment during measurement\u201d). Each Attribute has specified fields that are required or optional as defined in Table3 and Table6 below.","title":"How are Attributes defined?"},{"location":"high-level-overview/#how-are-states-defined","text":"There are 3 main states in which Data Objects exist: Templates, Spec, and Run. GEMD distinguishes between the generalization of what might be done (Template), the intent to do something (Spec), and the actual result of doing it (Run). As an example, one can have a Template for a Process Object defined as \u201csinter at {temperature} for {time} in kiln {id}\u201d. This would be the Template used for a Spec of a kiln process used in the production of alumina. The Spec of the Process object might be \u201csinter at 2400 K for 6 hours in kiln 14\u201d. The Process Run object would be what really happened when the process was conducted. For example, someone may have run the kiln and it ran at 2395 K. The Run of the Process object would be \u201csinter at 2395 K for 5.75 hours in kiln 14\u201d. All Data Objects (and all the Attributes that describe those Data Objects) in any State have specified fields that are required or optional. Table2 goes into further detail about the possible fields in all Data Objects and Attributes. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one Table2: Defines the possible fields in all Data Objects and Attributes in all states.","title":"How are States defined?"},{"location":"high-level-overview/#templates","text":"Templates are generalizations of Data Objects used to standardize data in GEMD. Templates are used at write time to validate data and at read time to associate groups of information together. Each Spec and Run Object or Attribute (excluding Ingredient Objects and Metadata Attributes) requires a linked Template to support this read and write time association and validation respectively.","title":"Templates"},{"location":"high-level-overview/#attribute-templates","text":"An Attribute Template specifies the bounds that are acceptable for an Attribute. For example, an Attribute Template could specify a Real value bounded between -3 and +17, or it could define a Categorical bound with the following allowed categories: \"salt\", \"not salt\". The values of an Attribute with an Attribute Template must conform to the bounds specified by the Template. If the value is not compatible with the Template (e.g., if the Template specifies that the value must be in the range [0, 1] but the value is 2), an error is thrown. Table3 below defines the possible fields in all Attributes in the Template state. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one description Optional one bounds Required one Table3 : Shows the fields available for Attributes in the Template state. The scope defines to which category of Attribute (Property, Parameter, or Condition) the Attribute Template applies.","title":"Attribute Templates"},{"location":"high-level-overview/#object-templates","text":"Object Templates are collections of Attribute Templates that together constrain the values of a Data Object's associated Attributes to valid ranges, and provide a common structure for describing similar Data Objects. Object Templates are useful for validating that all Data Objects being written or generated by a script are consistent and valid. In the future, Object Templates could be used to generate data input forms or similar interfaces. Table4 below defines the possible fields in all Data Objects in the Template state. Field Required/Optional Quantity Possible uids Optional many tags Optional many name Required one description Optional one Table4 : Shows the fields available for each category of Data Object in the Template state. All Object Templates can also have additional Attribute Bounds set on defined Attributes. These are additional bounds that can be applied to Attributes associated with that Data Object. For example, consider there exists a Condition Attribute Template called \"Oven Temperature\" that is defined from 0 to 10,000 Kelvin and a Process Object Template that includes the \"Oven Temperature\" Condition Template. Along with the Condition Template \u201cOven Temperature\u201d, the Process Template can include additional Attribute bounds and restrict the values that can be applied to that Condition between 300 and 600 Kelvin. That second restriction is represented by a second bound paired with the Condition Template in the Process Object Template. Table5 below identifies all the possible Attributes that each Data Object can contain in the Template state. Object Template Property Template Parameter Template Condition Template Material Template yes no no Process Template no yes yes Measurement Template yes yes yes Table5 : Shows which Attributes can be linked to each Data Object in the Template state.","title":"Object Templates"},{"location":"high-level-overview/#specs-and-runs","text":"Specs define the intent to do something, usually formalized in the format of an experiment request, the intention of an experiment, or the definition of a property. For example, the normal boiling point of pure water is 99.61 C, a spec. Runs describe how a material, process, or measurement were actually performed, defined, or evaluated and the end results of that evaluation. For example, a sample of water boiled at 101 C, a run.","title":"Specs and Runs"},{"location":"high-level-overview/#attribute-in-specs-and-runs","text":"Each Attribute has specified fields that are required or optional for both Spec or Run state. Table6 goes into further detail about the possible fields. Table6 represents the Attributes in diagram. Field Required/Optional Quantity Possible name Required one value Required one notes Optional one origin Required one template Optional one file_links Optional many Table6 : Shows the fields available for Attributes in the Spec and Run context. All attributes must specify the origin of their data as one of: Specified: it is the intention to have this value. Measured: this was directly measured during the Process or Measurement Run. Computed: this was calculated based on other measured or derived properties. Predicted: this was calculated based on a model, e.g., machine learning or simulation. Summary: this was calculated based on a set of the same property at a finer level of granularity (aggregation of data). Unknown: the origin is not known, typically when migrating legacy data. A value is a complex type that may contain both central (i.e., expected) and distributional (i.e., uncertainty) information. It also includes units for real (i.e., continuous) values.","title":"Attribute in Specs and Runs"},{"location":"high-level-overview/#data-object-specs-and-runs","text":"Object Specs may have an associated Object Template that bounds the valid units and values of the Attributes on the Spec. With the linking of Specs to Runs, Runs inherit associated Templates through Specs. For example, Process Runs associated with a Process Spec inherit the Template associated with the Spec, and their Attributes are thus also constrained by the Template. Many Specs can reference the same Object Template. Each Spec can be associated with at most one Object Template (for now). Many Runs can reference the same Spec. Each Run must be associated with exactly one Spec. As Object Specs define the intent to do something, they are more limited in possible fields than Runs. Table7 represents what additional fields are required or optional for Object Specs. Field Required/Optional Quantity Possible Spec or Run uids Optional many both tags Optional many both name Required one both notes Optional one both file_links Optional many both template Optional one Spec spec Required one Run Table7 : Shows the fields available for Material, Measurement, and Process Objects in the Spec and Run contexts. Ingredient Objects are treated a little differently from the other Objects in GEMD because they are mainly used to annotate a Material with information related to its usage in a Process. Note that constraints on name and labels follow from the allowed_names and allowed_labels fields of the Process Template. Table8 below identifies all the fields available in Ingredient Objects for both Specs and Runs. Field Required/Optional Quantity Possible In Spec or Run uids Optional many both tags Optional many both notes Optional one both file_links Optional many both name Optional one Spec labels Optional many Spec material Required one both (with material object from respective state) mass_fraction Optional one both volume_fraction Optional one both number_fraction Optional one both absolute_quantity Optional one both spec Required one Run Table8 : Shows the fields available for Ingredient Objects in the Spec and Run context.","title":"Data Object Specs and Runs"},{"location":"known-limitations/","text":"Known Limitations \u00b6 Purpose \u00b6 This set of documentation describes the Citrine data format, GEMD, that is independent of any implementation of the format. However , as the Citrine Platform is assumed to be the primary point of interaction between this data model and most users, known limitations of this model are documented here, with appropriate links to this page provided elsewhere in this documentation. Limitations \u00b6 The Citrine Platform cannot check for cycles in the material history. Material histories represent a chronology, so cycles in them represent time-travel (physically disallowed). We do not have the ability to check that writing an object doesn't create a cycle in some material history. The values of name and labels of Ingredient Runs are inherited from the associated Ingredient Specs, and thus are identically equal. However, this was not true in early designs. This means some older implementations may still have those fields in Ingredient Runs and there are therefore order-of-operations concerns that might get in the way of object validation. So long as a user uses the spec setter (or invokes the constructor with the spec argument) with an Ingredient Spec object (as opposed to a LinkByUID object), there should be no issue with validation on the Citrine Platform.","title":"Known Limitations"},{"location":"known-limitations/#known-limitations","text":"","title":"Known Limitations"},{"location":"known-limitations/#purpose","text":"This set of documentation describes the Citrine data format, GEMD, that is independent of any implementation of the format. However , as the Citrine Platform is assumed to be the primary point of interaction between this data model and most users, known limitations of this model are documented here, with appropriate links to this page provided elsewhere in this documentation.","title":"Purpose"},{"location":"known-limitations/#limitations","text":"The Citrine Platform cannot check for cycles in the material history. Material histories represent a chronology, so cycles in them represent time-travel (physically disallowed). We do not have the ability to check that writing an object doesn't create a cycle in some material history. The values of name and labels of Ingredient Runs are inherited from the associated Ingredient Specs, and thus are identically equal. However, this was not true in early designs. This means some older implementations may still have those fields in Ingredient Runs and there are therefore order-of-operations concerns that might get in the way of object validation. So long as a user uses the spec setter (or invokes the constructor with the spec argument) with an Ingredient Spec object (as opposed to a LinkByUID object), there should be no issue with validation on the Citrine Platform.","title":"Limitations"},{"location":"philosophy/","text":"GEMD Philosophy \u00b6 Scope \u00b6 GEMD records physical and contextual information about materials and chemicals. This includes: Physical properties of materials and chemicals Descriptions of processes and characterizations performed on the material, including who, when, and why Provenance of the materials and chemicals A controlled vocabulary for domain concepts like \"vapor pressure\" and \"universal testing machine\" Objective \u00b6 GEMD enables information reuse and supports a material and chemicals system of record. Guiding principles \u00b6 GEMD does not define a controlled vocabulary \u00b6 It is not the place of the data format to say \"Bandgap\" instead of \"band gap\" or \"Young's modulus\" instead of \"Young modulus\". Objects and Attributes have name fields that can take any value. Even the notion of equivalence/comparability is abstracted away to templates (see below), which can be used to define controlled vocabularies in data. Validations define a controlled vocabulary \u00b6 GEMD captures validation in the form of Attribute Templates and Object Templates . These same objects serve to define a controlled vocabulary of domain concepts. The way that GEMD indicates that a property is a \"vapor pressure\" vs an \"ambient pressure\" vs a \"pressure applied on the horizontal face\" is by defining templates for each of those concepts and assigning those templates to their corresponding properties. This controlled vocabulary of templates supports robust comparisons. If two attributes define the same attribute template, then they should be directly comparable. On the other hand, if two attributes only define the same dimension (e.g., mass-length-time) then they may correspond to distinct and incomparable physical concepts. Everything is bounded \u00b6 The bounds on real, integer, and categorical values do not support infinity or wildcard categories. If an Attribute is assigned an Attribute Template , then its values must be bounded. The utility is that those bounds define either a finite set of options the attribute might take, for categorical and integer types, or a finite range for real types. This defines a scale for evaluating how similar two attributes are set to select values from when inputting or generating data. How do we get away with this requirement? The universe only has so much energy, so there is a practical upper limit to most physical quantities. More practically, the physical systems present in materials and chemicals can range considerably in size, but not infinitely so. When defining the bounds in templates, it is important to have a broad range of use cases in mind. Attribute Templates should contain especially broad ranges, while Object Templates can refine those ranges to a tighter scope of application. Never turn away data \u00b6 If the data is in scope, then the data model should have a place to write it. Catch-all fields (e.g., notes ) are useful, but common notes patterns should be elevated into the spec. When linking data, the data author should be blocked by other data authors as infrequently as possible. Another consequence of never wanting to turn data away is that curation via template assignment is optional. It is better to have data with only unstructured context (e.g., notes) than to reject data because the user cannot or does not assign a template. This is particularly true for implementations that control the generation of templates, limiting the ability of any user to define an appropriate template. Process is a first-class citizen \u00b6 The same stuff processed in different ways results in different materials, so the process by which a material was created belongs on equal footing with the material itself. In GEMD, they are in a 1:1 correspondence with each other: every material object has a process object that produced it. It is required because a material cannot be described without describing its process. Multiple authors can contribute to the history of a material \u00b6 Over its lifetime, a material and its precursors frequently change hands. Consequently, the people who know about each processing and measurement step can be different. In extreme cases, a third party measurement might be deliberately blinded to the description of the sample being tested. The data model supports this by encoding information about a material in a set of objects, each scoped to contain the information that an individual or team would have. Each individual or team owns their steps in the process, but doesn't need to worry about the downstream steps. The objects are linked in a chronological order from oldest to most recent. We don't always get what we want \u00b6 But if we try sometimes, we record what we'll need later. GEMD distinguishes between the intent to do something (a Spec) and the reality of what happened (a Run). Further, a single intent can be realized multiple times. This lets GEMD capture both systematic and random errors. It also allows for the definition of intent to precede generation of physical artifacts, supporting information hand-offs to experimental groups. Uncertainty quantification is opt-out rather than opt-in \u00b6 No measurement can be absolutely certain, and no calculation derived from uncertain inputs can magically produce certain outputs. Capturing that uncertainty is incredibly valuable as it informs a wide variety of statistical analyses. Uncertainty can take many forms, which are represented by a variety of distribution Value Types , which must be used when recording physical information into Attributes . However, uncertainty quantification can be challenging and is often impossible in hindsight. Therefore, nominal values are permitted to express \"It was nominally X, but we don't know how certain we are about it.\" Material history is chronological \u00b6 For any given physical object, one can trace back the series of processes that generated it and the ingredient materials that went into those processes. We represent this chronological history as a directed acyclic graph where each material links to the process that created it and each process links to the materials that went into it. Each of those input materials must exist before the process occurs. As a consequence there can be no cycles in a well-formed material history, as that would imply a material being created and then traveling back in time to be used in one of the processes that were involved in creating it. Starting from a root material and following references in the material->process->ingredient->material order, one can traverse the entire history and never see the same object twice. Please see Known Limitations for details about limitations in enforcing this constraint.","title":"GEMD Philosophy"},{"location":"philosophy/#gemd-philosophy","text":"","title":"GEMD Philosophy"},{"location":"philosophy/#scope","text":"GEMD records physical and contextual information about materials and chemicals. This includes: Physical properties of materials and chemicals Descriptions of processes and characterizations performed on the material, including who, when, and why Provenance of the materials and chemicals A controlled vocabulary for domain concepts like \"vapor pressure\" and \"universal testing machine\"","title":"Scope"},{"location":"philosophy/#objective","text":"GEMD enables information reuse and supports a material and chemicals system of record.","title":"Objective"},{"location":"philosophy/#guiding-principles","text":"","title":"Guiding principles"},{"location":"philosophy/#gemd-does-not-define-a-controlled-vocabulary","text":"It is not the place of the data format to say \"Bandgap\" instead of \"band gap\" or \"Young's modulus\" instead of \"Young modulus\". Objects and Attributes have name fields that can take any value. Even the notion of equivalence/comparability is abstracted away to templates (see below), which can be used to define controlled vocabularies in data.","title":"GEMD does not define a controlled vocabulary"},{"location":"philosophy/#validations-define-a-controlled-vocabulary","text":"GEMD captures validation in the form of Attribute Templates and Object Templates . These same objects serve to define a controlled vocabulary of domain concepts. The way that GEMD indicates that a property is a \"vapor pressure\" vs an \"ambient pressure\" vs a \"pressure applied on the horizontal face\" is by defining templates for each of those concepts and assigning those templates to their corresponding properties. This controlled vocabulary of templates supports robust comparisons. If two attributes define the same attribute template, then they should be directly comparable. On the other hand, if two attributes only define the same dimension (e.g., mass-length-time) then they may correspond to distinct and incomparable physical concepts.","title":"Validations define a controlled vocabulary"},{"location":"philosophy/#everything-is-bounded","text":"The bounds on real, integer, and categorical values do not support infinity or wildcard categories. If an Attribute is assigned an Attribute Template , then its values must be bounded. The utility is that those bounds define either a finite set of options the attribute might take, for categorical and integer types, or a finite range for real types. This defines a scale for evaluating how similar two attributes are set to select values from when inputting or generating data. How do we get away with this requirement? The universe only has so much energy, so there is a practical upper limit to most physical quantities. More practically, the physical systems present in materials and chemicals can range considerably in size, but not infinitely so. When defining the bounds in templates, it is important to have a broad range of use cases in mind. Attribute Templates should contain especially broad ranges, while Object Templates can refine those ranges to a tighter scope of application.","title":"Everything is bounded"},{"location":"philosophy/#never-turn-away-data","text":"If the data is in scope, then the data model should have a place to write it. Catch-all fields (e.g., notes ) are useful, but common notes patterns should be elevated into the spec. When linking data, the data author should be blocked by other data authors as infrequently as possible. Another consequence of never wanting to turn data away is that curation via template assignment is optional. It is better to have data with only unstructured context (e.g., notes) than to reject data because the user cannot or does not assign a template. This is particularly true for implementations that control the generation of templates, limiting the ability of any user to define an appropriate template.","title":"Never turn away data"},{"location":"philosophy/#process-is-a-first-class-citizen","text":"The same stuff processed in different ways results in different materials, so the process by which a material was created belongs on equal footing with the material itself. In GEMD, they are in a 1:1 correspondence with each other: every material object has a process object that produced it. It is required because a material cannot be described without describing its process.","title":"Process is a first-class citizen"},{"location":"philosophy/#multiple-authors-can-contribute-to-the-history-of-a-material","text":"Over its lifetime, a material and its precursors frequently change hands. Consequently, the people who know about each processing and measurement step can be different. In extreme cases, a third party measurement might be deliberately blinded to the description of the sample being tested. The data model supports this by encoding information about a material in a set of objects, each scoped to contain the information that an individual or team would have. Each individual or team owns their steps in the process, but doesn't need to worry about the downstream steps. The objects are linked in a chronological order from oldest to most recent.","title":"Multiple authors can contribute to the history of a material"},{"location":"philosophy/#we-dont-always-get-what-we-want","text":"But if we try sometimes, we record what we'll need later. GEMD distinguishes between the intent to do something (a Spec) and the reality of what happened (a Run). Further, a single intent can be realized multiple times. This lets GEMD capture both systematic and random errors. It also allows for the definition of intent to precede generation of physical artifacts, supporting information hand-offs to experimental groups.","title":"We don't always get what we want"},{"location":"philosophy/#uncertainty-quantification-is-opt-out-rather-than-opt-in","text":"No measurement can be absolutely certain, and no calculation derived from uncertain inputs can magically produce certain outputs. Capturing that uncertainty is incredibly valuable as it informs a wide variety of statistical analyses. Uncertainty can take many forms, which are represented by a variety of distribution Value Types , which must be used when recording physical information into Attributes . However, uncertainty quantification can be challenging and is often impossible in hindsight. Therefore, nominal values are permitted to express \"It was nominally X, but we don't know how certain we are about it.\"","title":"Uncertainty quantification is opt-out rather than opt-in"},{"location":"philosophy/#material-history-is-chronological","text":"For any given physical object, one can trace back the series of processes that generated it and the ingredient materials that went into those processes. We represent this chronological history as a directed acyclic graph where each material links to the process that created it and each process links to the materials that went into it. Each of those input materials must exist before the process occurs. As a consequence there can be no cycles in a well-formed material history, as that would imply a material being created and then traveling back in time to be used in one of the processes that were involved in creating it. Starting from a root material and following references in the material->process->ingredient->material order, one can traverse the entire history and never see the same object twice. Please see Known Limitations for details about limitations in enforcing this constraint.","title":"Material history is chronological"},{"location":"specification/attribute-templates/","text":"Attribute Templates and Bounds \u00b6 An AttributeTemplate defines a domain concept by giving it a canonical name and bounds, which describes the values that are acceptable for an Attribute. For example, an attribute template could define a real value bounded between -3 and +17, or it could define a Categorical with the following allowed categories: \"salt\", \"not salt\". The values of attributes with Attribute Templates must conform to the bounds specified by the templates. If the value is not compatible with the template (e.g., if the template specifies that the value must be in the range [0, 1] but the value is 2), then the data are invalid. Figure1: How Attribute Templates help relate Attributes between Specs and Runs, and provide Bounds for Values. Each AttributeTemplate is primarily defined by a name , bounds . AttributeTemplates can also be described with tags, description, and scope. Field name Value type Default Description type String Req. One of: property_template , condition_template , parameter_template name String Req. The name of the template bounds Bounds Req. Description of values that are valid according to the template (see below) uids Map[String, String] Empty A collection of Unique Identifiers description String None Some text describing what this template is tags Set[String] Empty set Tags Attribute Templates are critical in defining which quantities are comparable or equivalent. When Attributes are added to core objects (Runs or Specs), they should be associated with an appropriate Attribute Template. This association is meant to inform how Values are collected and aggregated in downstream consumers of GEMD data. Constraints \u00b6 Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded Examples \u00b6 { \"type\" : \"property_template\", \"uids\" : { \"id\" : \"2e1bec7e-bda4-441d-bebb-1215bfa6ee0f\" }, \"tags\" : [ \"hardness::indentation::vickers\", \"Newage MT91 Tester::004\", \"astm_hardness::ASTM E-384\"], \"name\" : \"Vickers Hardness on Machine 4\", \"description\" : \"A Vickers indentation hardness test on the Newage MT91 Tester with machine id #4. Conforms to ASTM standard E-384.\", \"bounds\" : { \"type\" : \"real_bounds\", \"default_units\" : \"HV30/15\", \"lower_bound\" : 0.0, \"upper_bound\" : 10000.0 } } { \"type\": \"property_template\", \"id\" : \"2e1bec7e-bda4-441d-bebb-1215bfa6ee0f\", \"uids\" : {}, \"tags\" : [ \"#noindigo::newtonwaswrong\", \"taste::therainbow\", \"things_they_are_after::my_lucky_charms\", \"marketing::commercials::candy::skittles\", \"marketing::characters::cereal::leprechaun\" ], \"name\" : \"Rainbow Colors\", \"description\" : \"Colors in the rainbow\", \"bounds\" : { \"type\" : \"categorical_bounds\", \"categories\" : [ \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\" ] } } Real Bounds \u00b6 Real bounds are defined by a range of finite real values and a unit. For example: The band gap is defined from zero to 20 eV The lowest unoccupied molecular orbital (LUMO) is defined from negative 100 to zero eV The volume fraction in the austenite phase is defined from 0.0 to 1.0 and is dimensionless Real bounds can validate distributions over the real numbers. A real-valued distribution may be non-zero for points outside of the associated real bounds and still be valid. This is because common distributions such as a Gaussian are non-zero everywhere. If a Real Value is allowed to be non-zero outside the associated bounds, the conditions for validation are documented in the description of that type. Field name Value type Description type String always real_bounds default_units String Unit used to express the bounds lower_bound Number the lower bound upper_bound Number the upper bound Constraints \u00b6 Field name Relationship Field Name lower_bound <= upper_bound Example \u00b6 { \"type\" : \"real_bounds\", \"default_units\" : \"meters\", \"lower_bound\" : 0.0, \"upper_bound\" : 10.0 } Integer Bounds \u00b6 Integer bounds are defined by a range of integer values. For example: The number of power-cycles in a battery lifetime test is between 1 and 1,000,000 The position of a digital knob is between 1 and 10 The charge on an ion is between -128 and 128 Field name Value type Description type String always integer_bounds lower_bound Integer the inclusive lower bound upper_bound Integer the inclusive upper bound Constraints \u00b6 Field name Relationship Field Name lower_bound <= upper_bound Example \u00b6 { \"type\" : \"integer_bounds\", \"lower_bound\" : -128, \"upper_bound\" : 128 } Categorical Bounds \u00b6 Categorical bounds are defined by a set of valid category names. For example: Colors are one of: \"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Purple\" Answers are one of: \"Animal\", \"Vegetable\", \"Mineral\" Fats are one of: \"Saturated\", \"Mono-unsaturated\", \"Poly-unsaturated\" Field name Value type Description type String always categorical_bounds categories Set[String] A set of valid categorical values Example \u00b6 { \"type\" : \"categorical_bounds\", \"categories\" : [ \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\" ] } Composition Bounds \u00b6 Composition bounds are defined by a set of valid component names. For example: Steel phase is a mixture of Austentite, Allotriomorphic ferrite, Idiomorphic ferrite, Pearlite, ... (there are 10) Elemental composition is a mixture of the elements Vodka is a mixture of water, ethanol, and contaminants Field name Value type Description type String always composition_bounds components Set[String] A set of valid component names Example \u00b6 { \"type\" : \"composition_bounds\", \"components\" : [ \"water\", \"ethanol\", \"contaminants\" ] } For users of the gemd-python library, the Empirical Formula value type has an all_elements method to easily include the entire periodic table: CompositionBounds(components=EmpiricalFormula.all_elements()) . Molecular Structure Bounds \u00b6 Molecular structure bounds are used to describe an attribute template that expects a molecular structure type, but do not have any further parameterization. For example: Ligand structure is molecular structure Monomer is a molecular structure Field name Value type Description type String always molecular_structure_bounds Example \u00b6 { \"type\" : \"molecular_structure_bounds\" }","title":"Attribute Templates and Bounds"},{"location":"specification/attribute-templates/#attribute-templates-and-bounds","text":"An AttributeTemplate defines a domain concept by giving it a canonical name and bounds, which describes the values that are acceptable for an Attribute. For example, an attribute template could define a real value bounded between -3 and +17, or it could define a Categorical with the following allowed categories: \"salt\", \"not salt\". The values of attributes with Attribute Templates must conform to the bounds specified by the templates. If the value is not compatible with the template (e.g., if the template specifies that the value must be in the range [0, 1] but the value is 2), then the data are invalid. Figure1: How Attribute Templates help relate Attributes between Specs and Runs, and provide Bounds for Values. Each AttributeTemplate is primarily defined by a name , bounds . AttributeTemplates can also be described with tags, description, and scope. Field name Value type Default Description type String Req. One of: property_template , condition_template , parameter_template name String Req. The name of the template bounds Bounds Req. Description of values that are valid according to the template (see below) uids Map[String, String] Empty A collection of Unique Identifiers description String None Some text describing what this template is tags Set[String] Empty set Tags Attribute Templates are critical in defining which quantities are comparable or equivalent. When Attributes are added to core objects (Runs or Specs), they should be associated with an appropriate Attribute Template. This association is meant to inform how Values are collected and aggregated in downstream consumers of GEMD data.","title":"Attribute Templates and Bounds"},{"location":"specification/attribute-templates/#real-bounds","text":"Real bounds are defined by a range of finite real values and a unit. For example: The band gap is defined from zero to 20 eV The lowest unoccupied molecular orbital (LUMO) is defined from negative 100 to zero eV The volume fraction in the austenite phase is defined from 0.0 to 1.0 and is dimensionless Real bounds can validate distributions over the real numbers. A real-valued distribution may be non-zero for points outside of the associated real bounds and still be valid. This is because common distributions such as a Gaussian are non-zero everywhere. If a Real Value is allowed to be non-zero outside the associated bounds, the conditions for validation are documented in the description of that type. Field name Value type Description type String always real_bounds default_units String Unit used to express the bounds lower_bound Number the lower bound upper_bound Number the upper bound","title":"Real Bounds"},{"location":"specification/attribute-templates/#integer-bounds","text":"Integer bounds are defined by a range of integer values. For example: The number of power-cycles in a battery lifetime test is between 1 and 1,000,000 The position of a digital knob is between 1 and 10 The charge on an ion is between -128 and 128 Field name Value type Description type String always integer_bounds lower_bound Integer the inclusive lower bound upper_bound Integer the inclusive upper bound","title":"Integer Bounds"},{"location":"specification/attribute-templates/#categorical-bounds","text":"Categorical bounds are defined by a set of valid category names. For example: Colors are one of: \"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Purple\" Answers are one of: \"Animal\", \"Vegetable\", \"Mineral\" Fats are one of: \"Saturated\", \"Mono-unsaturated\", \"Poly-unsaturated\" Field name Value type Description type String always categorical_bounds categories Set[String] A set of valid categorical values","title":"Categorical Bounds"},{"location":"specification/attribute-templates/#composition-bounds","text":"Composition bounds are defined by a set of valid component names. For example: Steel phase is a mixture of Austentite, Allotriomorphic ferrite, Idiomorphic ferrite, Pearlite, ... (there are 10) Elemental composition is a mixture of the elements Vodka is a mixture of water, ethanol, and contaminants Field name Value type Description type String always composition_bounds components Set[String] A set of valid component names","title":"Composition Bounds"},{"location":"specification/attribute-templates/#molecular-structure-bounds","text":"Molecular structure bounds are used to describe an attribute template that expects a molecular structure type, but do not have any further parameterization. For example: Ligand structure is molecular structure Monomer is a molecular structure Field name Value type Description type String always molecular_structure_bounds","title":"Molecular Structure Bounds"},{"location":"specification/attributes/","text":"Attributes \u00b6 Properties are characteristics of a material that could be measured (e.g., chemical composition, density, or yield strength). I recorded a Measurement Run of the density of my cookie. I measured the property to be a Nominal Real Value of 604 kg/m\u00b3. Conditions are the environmental variables (typically measured) that may affect a process or measurement: e.g. Temperature, Pressure. The reading on the thermometer inside my oven as I bake cookies was 355 degrees, and I know that my thermometer is only accurate to +- 5 degrees, so I'll make that a Uniform Real Value with a lower_bound of 350 and an upper_bound of 360. Parameters are the non-environmental variables (typically specified and controlled) that may affect a process or measurement: e.g. Oven Dial Temperature Position for a kiln firing, or Magnification for a measurement taken with a SEM. The \"Bake Cookies\" Process Spec has two parameters: a Nominal Real Value of 30 minutes for bake duration, and a Nominal Real Value of 350 degrees for oven temperature setting I know my oven tends to run cold, so as I was baking I set my temperature setting to 360 degrees. I recorded this in the Process Run as a parameter with a Nominal Real Value of 360 Degrees. Typically, conditions are going to apply to measured environmental variables in Process Runs and Measurement Runs. It may be appropriate to specify a Parameter attribute on a Spec, and describe that attribute as a Condition on Runs of that Spec if the value is being measured as opposed to controlled during the Run. It may also be appropriate to include both a Parameter and a Condition on the Run if the value is both controlled and measured. The use of Conditions in Specs should be limited in favor of parameters. Attributes may be annotated with an Attribute Template , which defines a canonical name and bounds on the attribute. PropertyAndConditions \u00b6 PropertyAndConditions are known or unmeasured Properties (at specified Conditions) of a Material Spec . Typically, these will come from technical specification sheets of purchased ingredients or reference materials such as safety data sheets (SDS). I purchased 100% Ethanol. According to the SDS, pure ethanol has a Density (Property) of 0.789 g/cc at 20 degC (Condition 1) and 1 atm (Condition 2). I will add this as a PropertyAndConditions to the ethanol Material Spec . This PropertyAndConditions will have the density Property in the property field and a List containing both Conditions in the conditions field. I purchased 80% Ethanol. According to the Technical Specifications, the solution is 80% ethanol and 20% water (Property). I will add this Compositional Value as a PropertyAndConditions to the Material Spec . However, this PropertyAndConditions will only have information in the property field, as no associated conditions are needed. Origin \u00b6 Attributes are annotated with the origin of the data. This field can have the following values: measured : The Value of this Attribute was directly measured. predicted : The Value of this Attribute came from a model, such as a complex simulation, a machine learning--derived computation or rule-of-thumb estimation summary : The Value of this Attribute is calculated based on a set of the same property at a finer level of granularity (aggregation of data). specified : The Value of this Attribute was dictated, such as the oven temperature in a Process Spec . This value should only appear in Specs. computed : The Value of this Attribute was derived directly from measured values, such as computing the yield stress from a stress-strain curve or computing the density from known mass and volume measurements. unknown : The origin of this Value is unknown. This is the default value. Property, Condition, Parameter \u00b6 All three types of attributes have the same fields. Field name Value type Default Description type String Req. One of: property , condition , parameter value Value Req. Any Value type name String Req. The name of the attribute, which is used to identify it within a Data Object notes String None Some free-form notes about the attribute. origin measured , predicted , summary , specified , computed , unknown unknown The origin of the attribute template Attribute Template None Attribute Template which defines bounds file_links Set [File Links ] Empty set Links to associated files, with resource paths into the files API Constraints \u00b6 Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( notes ) <= 32,768 (32KB), UTF-8 Encoded template is a template type that matches the attribute type, e.g. PropertyTemplate for a Property value is a template 's Value Type value conforms to template . bounds Examples \u00b6 { \"type\" : \"property\", \"name\" : \"A Real Valued Property\", \"value\" : { \"type\" : \"uniform_real\", \"lower_bound\" : 1.995, \"upper_bound\" : 2.005, \"units\": \"inch\" }, \"origin\" : \"measured\", \"template\" : { \"name\" : \"A Property Template\", \"type\" : \"property_template\", \"bounds\" : { \"type\" : \"real_bounds\", \"lower_bound\" : 0.0, \"upper_bound\" : 10.0, \"default_units\": \"meters\" } }, \"file_links\" : [ { \"filename\" : \"How-to-make-lucky-charms.pdf\", \"url\" : \"https://example.com/files/file/d8f12919-b201-4186-be95-10525eb4256a/version/2\" } ] } { \"type\" : \"condition\", \"name\" : \"A Real Valued Condition\", \"value\" : { \"type\" : \"uniform_real\", \"lower_bound\" : 1.0, \"upper_bound\" : 2.0, \"units\": \"degC\" }, \"origin\" : \"measured\", \"template\" : { \"type\" : \"condition_template\", \"name\" : \"temperature\", \"bounds\" : { \"type\" : \"real_bounds\", \"lower_bound\" : 0.0, \"upper_bound\" : 1.0e6, \"default_units\": \"Kelvin\" } } } { \"type\" : \"parameter\", \"name\" : \"A Real Valued Parameter\", \"value\" : { \"type\" : \"nominal_real\", \"nominal\" : 1.0, \"units\": \"degC\" }, \"origin\" : \"specified\", } PropertyAndConditions \u00b6 Field name Value type Default Description type String Req. property_and_conditions property Property Req. Property of the Material Spec conditions Set[Condition] None List of conditions the Property is valid at Examples \u00b6 { \"type\": \"property_and_conditions\", \"conditions\": [{ \"type\": \"condition\", \"name\": \"ambient temperature\", \"origin\": \"unknown\", \"value\": { \"nominal\": 20.0, \"type\": \"nominal_real\", \"units\": \"degree_Celsius\" }, }, { \"type\": \"condition\", \"name\": \"atmospheric pressure\", \"origin\": \"unknown\", \"value\": { \"nominal\": 1.0, \"type\": \"nominal_real\", \"units\": \"atm\" } }], \"property\": { \"type\": \"property\", \"name\": \"density\", \"origin\": \"unknown\", \"value\": { \"nominal\": 0.7893, \"type\": \"nominal_real\", \"units\": \"gram / cubic_centimeter\" } } }","title":"Attributes"},{"location":"specification/attributes/#attributes","text":"Properties are characteristics of a material that could be measured (e.g., chemical composition, density, or yield strength). I recorded a Measurement Run of the density of my cookie. I measured the property to be a Nominal Real Value of 604 kg/m\u00b3. Conditions are the environmental variables (typically measured) that may affect a process or measurement: e.g. Temperature, Pressure. The reading on the thermometer inside my oven as I bake cookies was 355 degrees, and I know that my thermometer is only accurate to +- 5 degrees, so I'll make that a Uniform Real Value with a lower_bound of 350 and an upper_bound of 360. Parameters are the non-environmental variables (typically specified and controlled) that may affect a process or measurement: e.g. Oven Dial Temperature Position for a kiln firing, or Magnification for a measurement taken with a SEM. The \"Bake Cookies\" Process Spec has two parameters: a Nominal Real Value of 30 minutes for bake duration, and a Nominal Real Value of 350 degrees for oven temperature setting I know my oven tends to run cold, so as I was baking I set my temperature setting to 360 degrees. I recorded this in the Process Run as a parameter with a Nominal Real Value of 360 Degrees. Typically, conditions are going to apply to measured environmental variables in Process Runs and Measurement Runs. It may be appropriate to specify a Parameter attribute on a Spec, and describe that attribute as a Condition on Runs of that Spec if the value is being measured as opposed to controlled during the Run. It may also be appropriate to include both a Parameter and a Condition on the Run if the value is both controlled and measured. The use of Conditions in Specs should be limited in favor of parameters. Attributes may be annotated with an Attribute Template , which defines a canonical name and bounds on the attribute.","title":"Attributes"},{"location":"specification/attributes/#propertyandconditions","text":"PropertyAndConditions are known or unmeasured Properties (at specified Conditions) of a Material Spec . Typically, these will come from technical specification sheets of purchased ingredients or reference materials such as safety data sheets (SDS). I purchased 100% Ethanol. According to the SDS, pure ethanol has a Density (Property) of 0.789 g/cc at 20 degC (Condition 1) and 1 atm (Condition 2). I will add this as a PropertyAndConditions to the ethanol Material Spec . This PropertyAndConditions will have the density Property in the property field and a List containing both Conditions in the conditions field. I purchased 80% Ethanol. According to the Technical Specifications, the solution is 80% ethanol and 20% water (Property). I will add this Compositional Value as a PropertyAndConditions to the Material Spec . However, this PropertyAndConditions will only have information in the property field, as no associated conditions are needed.","title":"PropertyAndConditions"},{"location":"specification/attributes/#origin","text":"Attributes are annotated with the origin of the data. This field can have the following values: measured : The Value of this Attribute was directly measured. predicted : The Value of this Attribute came from a model, such as a complex simulation, a machine learning--derived computation or rule-of-thumb estimation summary : The Value of this Attribute is calculated based on a set of the same property at a finer level of granularity (aggregation of data). specified : The Value of this Attribute was dictated, such as the oven temperature in a Process Spec . This value should only appear in Specs. computed : The Value of this Attribute was derived directly from measured values, such as computing the yield stress from a stress-strain curve or computing the density from known mass and volume measurements. unknown : The origin of this Value is unknown. This is the default value.","title":"Origin"},{"location":"specification/attributes/#property-condition-parameter","text":"All three types of attributes have the same fields. Field name Value type Default Description type String Req. One of: property , condition , parameter value Value Req. Any Value type name String Req. The name of the attribute, which is used to identify it within a Data Object notes String None Some free-form notes about the attribute. origin measured , predicted , summary , specified , computed , unknown unknown The origin of the attribute template Attribute Template None Attribute Template which defines bounds file_links Set [File Links ] Empty set Links to associated files, with resource paths into the files API","title":"Property, Condition, Parameter"},{"location":"specification/attributes/#propertyandconditions_1","text":"Field name Value type Default Description type String Req. property_and_conditions property Property Req. Property of the Material Spec conditions Set[Condition] None List of conditions the Property is valid at","title":"PropertyAndConditions"},{"location":"specification/file-links/","text":"File Links \u00b6 Data objects are commonly derived from or related to files, such as the excel sheet from which a property was ingested, or an SEM image associated with a measurement, or a PDF describing detailed information for how to execute a process. Objects can reference those files using FileLink s, which simply specify a filename and URL. Field name Value type Description filename String The name of the file url String The URL at which the file (and associated metadata) can be accessed Constraints \u00b6 None Example \u00b6 { \"file_links\" : [ { \"filename\" : \"How-to-make-lucky-charms.pdf\", \"url\" : \"https://example.com/files/file/d8f12919-b201-4186-be95-10525eb4256a/version/2\" } ] }","title":"File Links"},{"location":"specification/file-links/#file-links","text":"Data objects are commonly derived from or related to files, such as the excel sheet from which a property was ingested, or an SEM image associated with a measurement, or a PDF describing detailed information for how to execute a process. Objects can reference those files using FileLink s, which simply specify a filename and URL. Field name Value type Description filename String The name of the file url String The URL at which the file (and associated metadata) can be accessed","title":"File Links"},{"location":"specification/object-templates/","text":"Object Templates \u00b6 Object Templates, like Attribute Templates, define a domain concept, such as convection baking in a standard residential oven, a cheesecake, or a taste test. Unlike Specs, Object Templates define ranges validity. Object Templates contain collections of Attribute Templates that together constrain the values of an object's associated attributes to valid ranges. They also define a canonical name, a description, and can be tagged. The parameters , properties , and conditions fields in Object Templates are defined as sets of pairs. Each pair contains an Attribute Template and a Bounds that further constrains the bounds in the Attribute template. For example, the baking temperature might generally be defined to be between 100 degF and 1500 degF, but a Process Template describing a specific oven model may constrain the baking temperature to be between 150 degF and 550 degF. The Bounds must fall within the Attribute Template's Bounds, and should be set to those Bounds if no further constraint is desired. Each Attribute Template can only be included in a given Object Template's Attribute list once (e.g., once in properties and once in conditions ). Figure 1: A fully-realized set of Run, Spec, Object Template, Attributes and Attribute Template, and Bounds objects. Process Template \u00b6 Process templates are further able to constrain the names and labels on their ingredients. If those sets are empty, then no constraint is implied. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"process_template\" tags Set[String] Empty set Tags name String Req. The name of the template allowed_names Set[String] Empty set The set of names that ingredients are allowed to use in their name field allowed_labels Set[String] Empty set The set of labels that ingredients are allowed to use in their labels field description String None Some text describing what this template is for. conditions Set[Pair( Condition Templates , Bounds )] Empty set Templates for associated conditions and bounds narrowing the allowable range parameters Set[Pair( Parameter Templates , Bounds )] Empty set Templates for associated parameters and bounds narrowing the allowable range Constraints \u00b6 Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded Bounds contained in Attribute template bounds parameters templates are unique within parameters condition templates are unique within conditions Example \u00b6 This is an example of a process template that has fully represented attribute templates. { \"type\" : \"process_template\", \"uids\" : { \"cookie_templates\" : \"baking_process_01\", \"id\" : \"064148e6-1cce-4d89-bfde-7ecd0aa4632b\" }, \"tags\" : [ \"baking::cookies\" ], \"name\" : \"Bake Cookies\", \"description\" : \"Template for baking cookies in an oven\", \"parameters\" : [ [ { \"name\" : \"Oven Temperature\", \"uids\" : {\"cookie_templates\": \"oven_temp\"}, \"tags\" : [\"oven_settings::temperature\"], \"description\" : \"A template for valid temperature ranges for baking cookies. Below 328K you're not even pasteurizing the dough.\", \"bounds\" : { \"default_units\" : \"kelvin\", \"type\" : \"real_bounds\", \"lower_bound\" : 328, \"upper_bound\" : 750 } }, { \"type\" : \"real_bounds\", \"default_units\" : \"kelvin\", \"lower_bound\" : 400, \"upper_bound\" : 500 } ], [ { \"name\" : \"Baking Time\", \"uids\" : {\"cookie_templates\": \"oven_time\"}, \"tags\" : [\"oven_settings::duration\"], \"description\" : \"A template for valid duration ranges for baking cookies.\", \"bounds\" : { \"default_units\" : \"seconds\", \"type\" : \"real_bounds\", \"lower_bound\" : 0, \"upper_bound\" : 86400 } }, { \"type\" : \"real_bounds\", \"default_units\" : \"seconds\", \"lower_bound\" : 300, \"upper_bound\" : 7200 } ] ] } Material Template \u00b6 The Property Templates and Bounds contained in a material template are used to validate the properties in any PropertyAndCondition s in the Material Spec . They are not, however, used to validate the properties in any Measurement Run objects attached to the Material Run . Rather, those properties are validated by the Measurement Template . Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"material_template\" tags Set[String] Empty set Tags name String Req. The name of the template description String None Some text describing what this template is for. properties Set[Pair( Property Templates , Bounds )] Empty set Templates for associated properties and bounds narrowing the allowable range Constraints \u00b6 Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded property templates are unique within properties Examples \u00b6 { \"type\" : \"material_template\", \"uids\" : { \"cookie_templates\" : \"choc_chip\", \"id\" : \"2e1bec7e-bda4-441d-bebb-1215bfa6ee0f\" }, \"tags\" : [], \"name\" : \"Chocolate Chip Cookie Template\", \"description\" : \"Template for chocolate chip cookie materials\", \"properties\" : [ [ { \"uids\" : {\"cookie_templates\" : \"choc_chip_comp_01\"}, \"tags\" : [\"ingredients::cookies::nutsallowed\"], \"name\" : \"Chocolate Chip Cookie Composition\", \"description\" : \"Specifying the composition of the linked cookie\", \"bounds\" : { \"type\" : \"categorical_bounds\", \"categories\" : [ \"flour\", \"baking soda\", \"baking powder\", \"salt\", \"butter\", \"granulated sugar\", \"brown sugar\", \"vanilla extract\", \"eggs\", \"chocolate chips\", \"chopped nuts\" ] } }, { \"type\" : \"categorical_bounds\", \"categories\" : [ \"flour\", \"baking soda\", \"baking powder\", \"salt\", \"butter\", \"granulated sugar\", \"brown sugar\", \"vanilla extract\", \"eggs\", \"chocolate chips\", \"chopped nuts\" ] } ] ] } Measurement Template \u00b6 Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"measurement_template\" tags Set[String] Empty set Tags name String Req. The name of the template description String None Some text describing what this template is for. conditions Set[Pair( Condition Templates , Bounds )] Empty set Templates for associated conditions and bounds narrowing the allowable range parameters Set[Pair( Parameter Templates , Bounds )] Empty set Templates for associated parameters and bounds narrowing the allowable range properties Set[Pair( Property Templates , Bounds )] Empty set Templates for associated properties and bounds narrowing the allowable range Constraints \u00b6 Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded property templates are unique within properties parameters templates are unique within parameters condition templates are unique within conditions Examples \u00b6 { \"type\" : \"measurement_template\", \"uids\" : { \"cookie_templates\" : \"choc_chip_hedonic\", \"id\" : \"664e5b79-4c16-46db-aa9e-ff70d79d2f79\" }, \"tags\" : [], \"name\" : \"Chocolate Chip Cookie Hedonic Index Measurement Template\", \"description\" : \"Template for chocolate chip cookie materials\", \"properties\" : [ [ { \"uids\" : {\"cookie_templates\": \"hedonic_index_prop\"}, \"tags\" : [], \"name\" : \"Chocolate Chip Cookie Hedonic Index\", \"description\" : \"The allowable range for the hedonic index of chocolate chip cookies.\", \"bounds\" : { \"type\" : \"real_bounds\", \"lower_bound\" : 9.99, \"upper_bound\" : 10, \"default_units\" : \"\" } }, { \"type\" : \"real_bounds\", \"lower_bound\" : 9.99, \"upper_bound\" : 10, \"default_units\" : \"\" } ] ], \"conditions\" : [ [ { \"name\" : \"Cookie Temperature\", \"uids\" : {\"cookie_templates\": \"cookie_eating_temp\"}, \"tags\" : [], \"description\" : \"A template for valid temperature ranges for eating cookies.\", \"bounds\" : { \"default_units\" : \"kelvin\", \"type\" : \"real_bounds\", \"lower_bound\" : 250, \"upper_bound\" : 380 } }, { \"default_units\" : \"kelvin\", \"type\" : \"real_bounds\", \"lower_bound\" : 250, \"upper_bound\" : 380 } ] ], \"parameters\": [ [ { \"name\" : \"Number of Cookies\", \"uids\" : {\"cookie_templates\": \"cookie_count\"}, \"tags\" : [\"chocula\"], \"description\" : \"A template for the number of cookies to eat for a hedonic index test.\", \"bounds\" : { \"type\" : \"integer_bounds\", \"lower_bound\" : 1, \"upper_bound\" : 1000 } }, { \"type\" : \"integer_bounds\", \"lower_bound\" : 1, \"upper_bound\" : 1000 } ] ] }","title":"Object Templates"},{"location":"specification/object-templates/#object-templates","text":"Object Templates, like Attribute Templates, define a domain concept, such as convection baking in a standard residential oven, a cheesecake, or a taste test. Unlike Specs, Object Templates define ranges validity. Object Templates contain collections of Attribute Templates that together constrain the values of an object's associated attributes to valid ranges. They also define a canonical name, a description, and can be tagged. The parameters , properties , and conditions fields in Object Templates are defined as sets of pairs. Each pair contains an Attribute Template and a Bounds that further constrains the bounds in the Attribute template. For example, the baking temperature might generally be defined to be between 100 degF and 1500 degF, but a Process Template describing a specific oven model may constrain the baking temperature to be between 150 degF and 550 degF. The Bounds must fall within the Attribute Template's Bounds, and should be set to those Bounds if no further constraint is desired. Each Attribute Template can only be included in a given Object Template's Attribute list once (e.g., once in properties and once in conditions ). Figure 1: A fully-realized set of Run, Spec, Object Template, Attributes and Attribute Template, and Bounds objects.","title":"Object Templates"},{"location":"specification/object-templates/#process-template","text":"Process templates are further able to constrain the names and labels on their ingredients. If those sets are empty, then no constraint is implied. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"process_template\" tags Set[String] Empty set Tags name String Req. The name of the template allowed_names Set[String] Empty set The set of names that ingredients are allowed to use in their name field allowed_labels Set[String] Empty set The set of labels that ingredients are allowed to use in their labels field description String None Some text describing what this template is for. conditions Set[Pair( Condition Templates , Bounds )] Empty set Templates for associated conditions and bounds narrowing the allowable range parameters Set[Pair( Parameter Templates , Bounds )] Empty set Templates for associated parameters and bounds narrowing the allowable range","title":"Process Template"},{"location":"specification/object-templates/#material-template","text":"The Property Templates and Bounds contained in a material template are used to validate the properties in any PropertyAndCondition s in the Material Spec . They are not, however, used to validate the properties in any Measurement Run objects attached to the Material Run . Rather, those properties are validated by the Measurement Template . Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"material_template\" tags Set[String] Empty set Tags name String Req. The name of the template description String None Some text describing what this template is for. properties Set[Pair( Property Templates , Bounds )] Empty set Templates for associated properties and bounds narrowing the allowable range","title":"Material Template"},{"location":"specification/object-templates/#measurement-template","text":"Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Req. \"measurement_template\" tags Set[String] Empty set Tags name String Req. The name of the template description String None Some text describing what this template is for. conditions Set[Pair( Condition Templates , Bounds )] Empty set Templates for associated conditions and bounds narrowing the allowable range parameters Set[Pair( Parameter Templates , Bounds )] Empty set Templates for associated parameters and bounds narrowing the allowable range properties Set[Pair( Property Templates , Bounds )] Empty set Templates for associated properties and bounds narrowing the allowable range","title":"Measurement Template"},{"location":"specification/objects/","text":"Objects \u00b6 There are two kinds of objects: Specs and Runs. Specs represent the intent and expectation of the material, process, ingredient, or measurement, while Runs capture what actually happened. This captures natural variations and forms an association between samples and design as multiple Runs of the same Spec. Specs are specific. In MaterialSpec , ProcessSpec , IngredientSpec , and MeasurementSpec objects, value should be given nominal values, e.g., real-valued attributes on Specs should have Nominal Values . This is in contrast to another common usage of the term \"Specification\" (or tolerance) as a range of accepted values, e.g., \"The material is in spec if the nitrogen impurity concentration is below 0.1%.\" In this data model, that notion of a \"spec\" that an object can \"be in\" is an Object Template . Specs can have an Object Template associated, which bounds the valid units and values of the Attributes on the Spec. Object Runs associated with an object Spec inherit the Object Template associated with the Spec, and their Attributes are thus also constrained by the Object Template . Many Specs can reference the same Object Template. Each Spec can be associated with at most one Object Template. Many Runs can reference the same Spec. Each Run must be associated with exactly one Spec. The mechanism for Attribute validation is through Attribute Templates . If the Attribute's template is set, the Attribute's Value is validated against the constraints defined in that template. If the Object Template has further restricted the bounds of the Attribute Template, then those tighter constraints are enforced. The Properties, Parameters and Conditions of Object Templates and of Objects are matched when they point at the same Attribute Template. An Object can have Attributes that are not defined in its Object Template , and an Object Template can have Attributes that are not defined in associated Objects. However, an Object cannot have two attributes of the same type (Property, Parameter, or Condition) with the same name or the same attribute template. Material History \u00b6 A material history is the complete set of objects that precede a Material Run in time, as well as the associated Specs and Templates. That final or ultimate material is called the Terminal Material . Given a dataset of relevant objects, a Material History would be collected by choosing a Terminal Material and then recursively: extracting the process that generated it extracting the ingredients that went into that process extracting the materials that constituted those ingredients until one reaches a point that a process has no recorded ingredients (e.g., I purchased a bag of flour). The dataset itself may have a complicated web of relationships (e.g., I made 12 different loaves of bread from one bag of flour) and the material history is just one example of a way to consider that dataset. Which materials would be considered terminal depend on context. A steelmaker might consider a steel plate to be terminal in their process. A machinist might take that plate as input for the dog bone they manufacture as terminal in their process. A technician might take that dog bone as input to destructive testing, and then a scrapper would feed the broken dog bone back as feedstock for another steelmaker. Every history has one terminal material. Recipe \u00b6 A recipe is the set of Specs and Templates that underlie a Material History. It represents the set of steps to be attempted to produce a target material. A recipe could be shared by many material histories or may just represent one. A recipe and any associated material histories should share the same graph structure. Process Spec \u00b6 An expectation of a process. Processes transform zero or more input materials into exactly one output material. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"process_spec\" name String Required The name of the Spec notes String None Some free-form notes about the Spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Process Template None A template bounding the valid values for parameters and conditions on this process. parameters Set[ Parameters ] Empty Specified parameters for the Process Spec conditions Set[ Conditions ] Empty Specified conditions for the Process Spec ingredients Set[ Ingredient Spec ] Implicit Ingredient Specs output_material Material Spec Implicit Output Material Spec Constraints \u00b6 All Attributes sharing an Attribute Template with an Attribute on the associated Object Template will be constrained by the (potentially tighter) bounds set in the template Process Template. Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded len( description ) <= 32,768 (32KB), UTF-8 Encoded parameter names must be unique among parameter names condition names must be unique among condition names parameter templates must be unique among the templates of parameters condition templates must be unique among the templates of conditions output_material must be unique globally Example \u00b6 { \"type\" : \"process_spec\", \"uids\" : { \"id\" : \"064148e6-1cce-4d89-bfde-7ecd0aa4632b\" }, \"tags\" : [ \"baking::cookies\" ], \"name\" : \"Bake Cookies\", \"notes\" : \"Process Spec for baking cookies in an oven\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"baking_process_01\" }, \"file_links\" : [ { \"filename\" : \"nestle-tollhouse-recipe.pdf\", \"url\" : \"https://example.com/file/d8f12919-b201-4186-be95-10525eb4256a/version/2\" } ], \"parameters\" : [ { \"type\" : \"parameter\", \"name\" : \"Oven Temperature\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"oven_temp\" }, \"tags\" : [\"oven_settings::duration\"], \"value\" : { \"type\" : \"nominal_real\", \"nominal\" : 450, \"units\" : \"kelvin\" } }, { \"type\" : \"parameter\", \"name\" : \"Baking Time\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"oven_time\" }, \"tags\" : [\"oven_settings::duration\"], \"value\" : { \"type\" : \"nominal_real\", \"units\" : \"seconds\", \"nominal\" : 600 } } ], \"ingredients\" : [ { \"type\" : \"link_by_uid\", \"scope\" : \"cookie ingredients\", \"id\" : \"chocolate chip cookie batter\" }, { \"type\" : \"link_by_uid\", \"scope\" : \"secret ingredients\", \"id\" : \"love\" } ], \"output_material\" : { \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"18d95397-4887-48f0-bdda-94a9a4c5ef45\" } } Process Run \u00b6 A particular instance of a process. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"process_run\" name String Required The name of the Process Run notes String None Some free-form notes about the Process Run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API source Source None provenance information for the process spec Process Spec Required Spec for this process parameters Set[ Parameters ] Empty Measured parameters for the Process Run conditions Set[ Conditions ] Empty Measured conditions for the Process Run ingredients Set[ Ingredient Run ] Implicit Ingredient Runs output_material Material Run Implicit Output Material Run Constraints \u00b6 Same as ProcessSpec , but with the template inherited from the spec , i.e., spec.template . Example \u00b6 { \"type\" : \"process_run\", \"uids\" : { \"cookie_ids\" : \"choc_chip_proc_001_run_006\", \"id\" : \"ea7af3f4-8dbf-41ba-8084-c6f2e31907a5\" }, \"tags\" : [ \"baking::cookies\" ], \"name\" : \"Bake Cookies Fo' Real\", \"notes\" : \"Process Run baking some chocolate chip cookies in an oven\", \"process_spec\" : { \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"064148e6-1cce-4d89-bfde-7ecd0aa4632b\" }, \"parameters\" : [ { \"type\" : \"parameter\", \"name\" : \"Oven Temperature\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"oven_temp\" }, \"tags\" : [\"oven_settings::temperature\"], \"value\" : { \"type\" : \"uniform_real\", \"lower_bound\" : 447.5, \"upper_bound\" : 452.5, \"units\" : \"kelvin\" } }, { \"type\" : \"parameter\", \"name\" : \"Baking Time\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"oven_time\" }, \"tags\" : [\"oven_settings::duration\"], \"value\" : { \"type\" : \"nominal_real\", \"units\" : \"seconds\", \"nominal\" : 614 } } ], \"ingredients\" : [ { \"type\" : \"link_by_uid\", \"scope\" : \"cookie ingredients\", \"id\" : \"chocolate chip cookie batter #45 in cookie 6\" }, { \"type\" : \"link_by_uid\", \"scope\" : \"secret ingredients\", \"id\" : \"love #724 in cookie 6\" } ], \"output_material\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie ids\", \"id\" : \"chocolate_chip_00038\" } } Ingredient Spec \u00b6 Ingredient Specs represent the intent for an ingredient, which annotates a material with information related to its usage in an individual process. Note that the name and labels for an Ingredient Spec are shared with all associated Ingredient Runs. These might be better thought of as the name of the role of a material in the process (e.g., binder) and not of the material itself (e.g., Portland cement). Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"ingredient_spec\" name String Required The name of the ingredient, unique within the process that contains it labels Set[String] Empty Additional labels on the ingredient for describing the type or role of the ingredient material Material Spec Required Material that is this ingredient process Process Spec Required Process that the ingredient is used in notes String Empty Some free-form notes about the Spec tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API mass_fraction Real Value None The mass fraction of the ingredient in the process volume_fraction Real Value None The volume fraction of the ingredient in the process number_fraction Real Value None The number fraction (i.e., mole fraction) of the ingredient in the process absolute_quantity Real Value None The absolute quantity of the ingredient in the process Note that \"fraction of the ingredient\" refers to the amount of the ingredient divided by the total amount of material going into the process, not the fraction of the total amount of ingredient.material used in the process. Constraints \u00b6 Field name Relationship Field Name len( name ) <= 128, UTF-8 Encoded mass_fraction <= 1 volume_fraction <= 1 number_fraction <= 1 mass_fraction.units == dimensionless volume_fraction.units == dimensionless number_fraction.units == dimensionless name must be unique among the ingredients of process name must be contained process.template.allowed_names , if allowed_names defined labels must be contained process.template.allowed_labels , if allowed_labels defined Example \u00b6 { \"type\" : \"ingredient_spec\", \"material\" :{ \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"18d95397-4887-48f0-bdda-94a9a4c5ef45\" }, \"process\" :{ \"type\" : \"link_by_uid\", \"scope\" : \"my_scope\", \"id\" : \"a-cool-process\" }, \"uids\" : { \"cookie_ids\" : \"choc_chip_spec_001_in_sandwich\" }, \"notes\" : \"Chocolate chip cookies used in making an ice cream sandwich\", \"absolute_quantity\" : { \"type\" : \"nominal_integer\", \"nominal\" : 2 }, \"mass_fraction\" : { \"type\" : \"nominal_real\", \"nominal\" : 0.35 }, \"name\" : \"cookie\", \"labels\" : [\"faces\"] } Ingredient Run \u00b6 A particular instance of an Ingredient Spec. Note that the name and labels for an Ingredient Run are inherited from its Spec. This is a change from the initial design of the data structure, and thus some implementations may still have name and labels associated with Ingredient Runs. See Known Limitations . Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"ingredient_run\" name String Implicit The name of the Ingredient Run (inherited from spec) labels Set[String] Implicit Additional labels on the ingredient for describing the type or role of the ingredient (inherited from spec) material Material Run Required Material that is this ingredient process Process Run Required Process that the ingredient is used in notes String None Some free-form notes about the run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API mass_fraction Real Value None The mass fraction of the ingredient in the process volume_fraction Real Value None The volume fraction of the ingredient in the process number_fraction Real Value None The number fraction of the ingredient in the process absolute_quantity Real Value None The absolute quantity of the ingredient in the process spec Ingredient Spec Required The Spec of which this is a Run Note that \"fraction of the ingredient\" refers to the amount of the ingredient divided by the total amount of material going into the process, not the fraction of the total amount of ingredient.material used in the process. Constraints \u00b6 Field name Relationship Field Name mass_fraction <= 1 volume_fraction <= 1 number_fraction <= 1 mass_fraction.units == dimensionless volume_fraction.units == dimensionless number_fraction.units == dimensionless An Ingredient Run and its Spec must be paired with a linked Material Run/Spec pair and with a linked Process Run/Spec pair. The Spec's Process and the Process's Spec must point to the same Process Spec. The Spec's Material and the Material's Spec must point to the same Material Spec. Field name Relationship Field Name process.spec = spec.process material.spec = spec.material Example \u00b6 { \"type\" : \"ingredient_run\", \"material\" :{ \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"18d95397-4887-48f0-bdda-94a9a4c5ef45\" }, \"process\" :{ \"type\" : \"link_by_uid\", \"scope\" : \"my_scope\", \"id\" : \"a-cool-process\" }, \"uids\" : { \"cookie_ids\" : \"choc_chip_run_4_in_sandwich_7\" }, \"notes\" : \"Chocolate chip cookie batch 4 used in making an ice cream sandwich batch 7\", \"absolute_quantity\" : { \"type\" : \"uniform_integer\", \"lower_bound\" : 2, \"upper_bound\" : 2 }, \"mass_fraction\" : { \"type\" : \"normal_real\", \"mean\" : 0.347, \"std\" : 0.002 } } Material Spec \u00b6 The expectation for a material. Materials have exactly one producing process. Material Specs may include expected properties, but do so via the PropertyAndConditions compound attribute. In this way, Material Specs can associate an expected property value with the conditions under which it is expected. For example, if a material is purchased and its Safety Data Sheet quotes a normal boiling point of 54 C, a property is known even though there is never an explicit measurement of that property by a person in the lab. It could therefore be annotated with a Boiling Temperature of 54 C (property) at 1 atm (condition). Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"material_spec\" name String Required The name of the Spec notes String None Some free-form notes about the Spec tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Material Template None A template bounding the valid values for properties of this material properties Set[ PropertyAndConditions ] Empty Expected properties for the Material Spec at the given conditions process Process Spec Required The Process Spec that produces this material Constraints \u00b6 All Attributes sharing an Attribute Template with an Attribute on the associated Object Template will be constrained by the (potentially tighter) bounds set in the template Material Template. All Conditions must be linked to a Property through the point mechanism. Field name Relationship Field Name property names must be unique among property names process must be unique globally Example \u00b6 { \"type\" : \"material_spec\", \"uids\" : { \"cookie_ids\" : \"choc_chip_spec_001\", \"id\" : \"18d95397-4887-48f0-bdda-94a9a4c5ef45\" }, \"name\" : \"Chocolate Chip Cookie Spec\", \"notes\" : \"Material Spec for chocolate chip cookies\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"choc_chip_001\" }, \"properties\" : [ { \"type\": \"property_and_conditions\", \"conditions\": [{ \"type\": \"condition\", \"name\": \"ambient temperature\", \"origin\": \"unknown\", \"value\": { \"nominal\": 20.0, \"type\": \"nominal_real\", \"units\": \"degree_Celsius\" }, \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"amb_temp_01\" }, }, { \"type\": \"condition\", \"name\": \"atmospheric pressure\", \"origin\": \"unknown\", \"value\": { \"nominal\": 1.0, \"type\": \"nominal_real\", \"units\": \"atm\" }, \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"amb_pressure_01\" }, }], \"property\": { \"type\": \"property\", \"name\": \"density\", \"origin\": \"unknown\", \"value\": { \"nominal\": 1.2, \"type\": \"nominal_real\", \"units\": \"gram / cubic_centimeter\" }, \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"prop_density_01\" }, } }, { \"type\": \"property_and_conditions\", \"conditions\": null, \"property\": { \"name\" : \"Cookie Composition\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"choc_chip_comp_01\" }, \"value\" : { \"type\" : \"nominal_composition\", \"quantities\" : { \"flour\" : 355, \"baking soda\" : 6, \"baking powder\" : 9, \"salt\" : 8, \"butter\": 225, \"granulated sugar\" : 205, \"brown sugar\" : 225, \"vanilla extract\" : 15, \"eggs\" : 50, \"chocolate chips\" : 395, \"chopped nuts\" : 225 } } } }], \"process_spec\" : { \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"064148e6-1cce-4d89-bfde-7ecd0aa4632b\" } } Material Run \u00b6 A particular instance of a material, e.g., a sample, ingot, or wafer. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"material_run\" name String Required The name of the Material Run notes String None Some free-form notes about the Material Run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API spec Material Spec Required The Material Spec of which this is a run process Process Run Required The Process Run that produced this material measurements Set[ Measurement Run ] Implicit characterizations of this Material Run sample_type experimental , production , or virtual , unknown unknown Context of how this material was made to be Constraints \u00b6 Same as Material Spec, but with the template inherited from the spec (i.e., spec.template ). A Material Run along with its Spec and process must form a \"square.\" That is, the Spec's Process and the Process's Spec must point to the same Process Spec. Field name Relationship Field Name process.spec = spec.process Example \u00b6 { \"type\" : \"material_run\", \"uids\" : { \"cookie_ids\" : \"choc_chip_001_run_006\" }, \"name\" : \"Chocolate Chip Cookie Run 006\", \"notes\" : \"Material Run for chocolate chip cookies\", \"sample_type\" : \"production\", \"spec\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\" : \"choc_chip_001\" }, \"process\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\": \"choc_chip_proc_001_run_006\" }, \"measurements\" : [ { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\" : \"choc_chip_001_hedonic_006\" } ] } Measurement Spec \u00b6 An expectation for a measurement, indicating the parameters of and conditions under which to perform the measurement. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"measurement_spec\" name String Required The name of the Spec notes String None Some free-form notes about the Spec tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Measurement Template None A template bounding the valid values for parameter and conditions of the measurement. parameters Set[ Parameters ] Empty Specified parameters for the measurement conditions Set[ Conditions ] Empty Specified conditions for the measurement Constraints \u00b6 All attributes sharing an Attribute Template with an attribute on the associated Object Template will be constrained by the (potentially tighter) bounds set in the template . Field name Relationship Field Name property names must be unique among property names condition names must be unique among condition names parameter names must be unique among parameter names property templates must be unique among the templates of properties parameter templates must be unique among the templates of parameters condition templates must be unique among the templates of conditions Example \u00b6 { \"type\" : \"measurement_spec\", \"uids\" : { \"cookie_ids\" : \"choc_chip_hedonic_spec\" }, \"name\" : \"Chocolate Chip Cookie Hedonic Index Measurement Spec\", \"notes\" : \"Measurement Specs for measuring the hedonic index of chocolate chip cookies\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"choc_chip_hedonic\" }, \"parameters\" : [ { \"type\" : \"parameter\", \"name\" : \"Cookie Quantity\", \"notes\" : \"You'll want to eat at least this many cookies for the hedonic index test\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"cookie_count\" }, \"value\" : { \"type\" : \"nominal_integer\", \"nominal\" : 7 } } ], \"conditions\" : [ { \"type\" : \"condition\", \"name\" : \"Cookie Temperature\", \"notes\" : \"Let them cool, or you'll burn your mouth and ruin the test.\", \"origin\" : \"specified\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"cookie_eating_temp\" }, \"value\" : { \"type\" : \"nominal_real\", \"nominal\" : 320, \"units\" : \"kelvin\" } } ] } Measurement Run \u00b6 A particular instance of a measurement. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"measurement_run\" name String Required The name of the Measurement Run notes String None Some free-form notes about the Measurement Run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API source Source None provenance information for the measurement spec Measurement Spec Required The Measurement Spec of which this is a run material Material Run Required The Material Run being measured parameters Set[ Parameters ] Empty Measured parameters for the measurement conditions Set[ Conditions ] Empty Measured conditions for the measurement properties Set[ Properties ] Empty Measured properties for the measurement Constraints \u00b6 Field name Relationship Field Name property names must be unique among property names condition names must be unique among condition names parameter names must be unique among parameter names property templates must be unique among the templates of properties parameter templates must be unique among the templates of parameters condition templates must be unique among the templates of conditions Example \u00b6 { \"type\" : \"measurement_run\", \"uids\" : { \"cookie_ids\" : \"choc_chip_hedonic_run_006\" }, \"name\" : \"Chocolate Chip Hedonic Measurement\", \"notes\" : \"Rate the cookies on a scale from 9.9-10\", \"measurement_spec\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\" : \"choc_chip_hedonic_spec\" }, \"material_run\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_ids\", \"id\": \"choc_chip_001_run_006\" }, \"properties\" : [ { \"type\" : \"property\", \"name\" : \"Chocolate Chip Cookie Hedonic Index\", \"notes\" : \"delish\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"hedonic_index_prop\" }, \"value\" : { \"type\" : \"nominal_real\", \"nominal\" : 9.997, \"units\" : \"\" } } ], \"conditions\" : [ { \"type\" : \"condition\", \"name\" : \"Measured Cookie Temperature\", \"notes\" : \"used a thermopen\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"cookie_eating_temp\" }, \"value\" : { \"type\" : \"uniform_real\", \"lower_bound\" : \"318.15\", \"upper_bound\" : \"318.25\", \"units\" : \"kelvin\" } } ], \"parameters\" : [ { \"type\" : \"parameter\", \"name\" : \"Cookie Quantity\", \"notes\" : \"I kept going and lost count.\", \"origin\" : \"measured\", \"template\" : { \"type\" : \"link_by_uid\", \"scope\" : \"cookie_templates\", \"id\" : \"cookie_count\" }, \"value\" : { \"type\" : \"uniform_integer\", \"lower_bound\" : 7, \"upper_bound\" : 12 } } ] } Source \u00b6 Provenance is the documented history of an Object. This includes information such as who performed a measurement, the literature source describing the design of a process, or the purveyor and catalog number for a purchased material. This type of information tends to have limited value for modeling and other analysis but is essential for verification and auditing. At present the only type of source supported is who performed a task and when they did so. Sources can be added to Process Run and Measurement Run Objects only. Field name Value type Default Description type String Required \"performed_source\" performed_by String None The person who performed the measurement performed_date String None The date the measurement was performed; ISO-8601 date-formatted string (YYYY-MM-DD or YYYY-MM-DDTHH:mm:SS) Example \u00b6 { \"type\": \"performed_source\", \"performed_by\": \"joe@abc.com\", \"performed_date\": \"2015-03-14T15:09:27\" } Common Motifs \u00b6 Multiple Outputs \u00b6 A process that produces many output Materials should be characterized through individual Process Runs for each output Material, even if the process occurred in the same piece of equipment. Multiple Mixing Steps \u00b6 If a mixing process is run multiple times, for example, to incorporate \"a little extra\" of a certain ingredient, each subsequent mixing step should have a unique instance of an \"Additional Mixing\" Process Run and Spec, which, crucially, should point to a Process Template distinct from the initial mixing Process Template.","title":"Objects"},{"location":"specification/objects/#objects","text":"There are two kinds of objects: Specs and Runs. Specs represent the intent and expectation of the material, process, ingredient, or measurement, while Runs capture what actually happened. This captures natural variations and forms an association between samples and design as multiple Runs of the same Spec. Specs are specific. In MaterialSpec , ProcessSpec , IngredientSpec , and MeasurementSpec objects, value should be given nominal values, e.g., real-valued attributes on Specs should have Nominal Values . This is in contrast to another common usage of the term \"Specification\" (or tolerance) as a range of accepted values, e.g., \"The material is in spec if the nitrogen impurity concentration is below 0.1%.\" In this data model, that notion of a \"spec\" that an object can \"be in\" is an Object Template . Specs can have an Object Template associated, which bounds the valid units and values of the Attributes on the Spec. Object Runs associated with an object Spec inherit the Object Template associated with the Spec, and their Attributes are thus also constrained by the Object Template . Many Specs can reference the same Object Template. Each Spec can be associated with at most one Object Template. Many Runs can reference the same Spec. Each Run must be associated with exactly one Spec. The mechanism for Attribute validation is through Attribute Templates . If the Attribute's template is set, the Attribute's Value is validated against the constraints defined in that template. If the Object Template has further restricted the bounds of the Attribute Template, then those tighter constraints are enforced. The Properties, Parameters and Conditions of Object Templates and of Objects are matched when they point at the same Attribute Template. An Object can have Attributes that are not defined in its Object Template , and an Object Template can have Attributes that are not defined in associated Objects. However, an Object cannot have two attributes of the same type (Property, Parameter, or Condition) with the same name or the same attribute template.","title":"Objects"},{"location":"specification/objects/#material-history","text":"A material history is the complete set of objects that precede a Material Run in time, as well as the associated Specs and Templates. That final or ultimate material is called the Terminal Material . Given a dataset of relevant objects, a Material History would be collected by choosing a Terminal Material and then recursively: extracting the process that generated it extracting the ingredients that went into that process extracting the materials that constituted those ingredients until one reaches a point that a process has no recorded ingredients (e.g., I purchased a bag of flour). The dataset itself may have a complicated web of relationships (e.g., I made 12 different loaves of bread from one bag of flour) and the material history is just one example of a way to consider that dataset. Which materials would be considered terminal depend on context. A steelmaker might consider a steel plate to be terminal in their process. A machinist might take that plate as input for the dog bone they manufacture as terminal in their process. A technician might take that dog bone as input to destructive testing, and then a scrapper would feed the broken dog bone back as feedstock for another steelmaker. Every history has one terminal material.","title":"Material History"},{"location":"specification/objects/#recipe","text":"A recipe is the set of Specs and Templates that underlie a Material History. It represents the set of steps to be attempted to produce a target material. A recipe could be shared by many material histories or may just represent one. A recipe and any associated material histories should share the same graph structure.","title":"Recipe"},{"location":"specification/objects/#process-spec","text":"An expectation of a process. Processes transform zero or more input materials into exactly one output material. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"process_spec\" name String Required The name of the Spec notes String None Some free-form notes about the Spec. tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Process Template None A template bounding the valid values for parameters and conditions on this process. parameters Set[ Parameters ] Empty Specified parameters for the Process Spec conditions Set[ Conditions ] Empty Specified conditions for the Process Spec ingredients Set[ Ingredient Spec ] Implicit Ingredient Specs output_material Material Spec Implicit Output Material Spec","title":"Process Spec"},{"location":"specification/objects/#process-run","text":"A particular instance of a process. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"process_run\" name String Required The name of the Process Run notes String None Some free-form notes about the Process Run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API source Source None provenance information for the process spec Process Spec Required Spec for this process parameters Set[ Parameters ] Empty Measured parameters for the Process Run conditions Set[ Conditions ] Empty Measured conditions for the Process Run ingredients Set[ Ingredient Run ] Implicit Ingredient Runs output_material Material Run Implicit Output Material Run","title":"Process Run"},{"location":"specification/objects/#ingredient-spec","text":"Ingredient Specs represent the intent for an ingredient, which annotates a material with information related to its usage in an individual process. Note that the name and labels for an Ingredient Spec are shared with all associated Ingredient Runs. These might be better thought of as the name of the role of a material in the process (e.g., binder) and not of the material itself (e.g., Portland cement). Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"ingredient_spec\" name String Required The name of the ingredient, unique within the process that contains it labels Set[String] Empty Additional labels on the ingredient for describing the type or role of the ingredient material Material Spec Required Material that is this ingredient process Process Spec Required Process that the ingredient is used in notes String Empty Some free-form notes about the Spec tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API mass_fraction Real Value None The mass fraction of the ingredient in the process volume_fraction Real Value None The volume fraction of the ingredient in the process number_fraction Real Value None The number fraction (i.e., mole fraction) of the ingredient in the process absolute_quantity Real Value None The absolute quantity of the ingredient in the process Note that \"fraction of the ingredient\" refers to the amount of the ingredient divided by the total amount of material going into the process, not the fraction of the total amount of ingredient.material used in the process.","title":"Ingredient Spec"},{"location":"specification/objects/#ingredient-run","text":"A particular instance of an Ingredient Spec. Note that the name and labels for an Ingredient Run are inherited from its Spec. This is a change from the initial design of the data structure, and thus some implementations may still have name and labels associated with Ingredient Runs. See Known Limitations . Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"ingredient_run\" name String Implicit The name of the Ingredient Run (inherited from spec) labels Set[String] Implicit Additional labels on the ingredient for describing the type or role of the ingredient (inherited from spec) material Material Run Required Material that is this ingredient process Process Run Required Process that the ingredient is used in notes String None Some free-form notes about the run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API mass_fraction Real Value None The mass fraction of the ingredient in the process volume_fraction Real Value None The volume fraction of the ingredient in the process number_fraction Real Value None The number fraction of the ingredient in the process absolute_quantity Real Value None The absolute quantity of the ingredient in the process spec Ingredient Spec Required The Spec of which this is a Run Note that \"fraction of the ingredient\" refers to the amount of the ingredient divided by the total amount of material going into the process, not the fraction of the total amount of ingredient.material used in the process.","title":"Ingredient Run"},{"location":"specification/objects/#material-spec","text":"The expectation for a material. Materials have exactly one producing process. Material Specs may include expected properties, but do so via the PropertyAndConditions compound attribute. In this way, Material Specs can associate an expected property value with the conditions under which it is expected. For example, if a material is purchased and its Safety Data Sheet quotes a normal boiling point of 54 C, a property is known even though there is never an explicit measurement of that property by a person in the lab. It could therefore be annotated with a Boiling Temperature of 54 C (property) at 1 atm (condition). Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"material_spec\" name String Required The name of the Spec notes String None Some free-form notes about the Spec tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Material Template None A template bounding the valid values for properties of this material properties Set[ PropertyAndConditions ] Empty Expected properties for the Material Spec at the given conditions process Process Spec Required The Process Spec that produces this material","title":"Material Spec"},{"location":"specification/objects/#material-run","text":"A particular instance of a material, e.g., a sample, ingot, or wafer. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"material_run\" name String Required The name of the Material Run notes String None Some free-form notes about the Material Run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API spec Material Spec Required The Material Spec of which this is a run process Process Run Required The Process Run that produced this material measurements Set[ Measurement Run ] Implicit characterizations of this Material Run sample_type experimental , production , or virtual , unknown unknown Context of how this material was made to be","title":"Material Run"},{"location":"specification/objects/#measurement-spec","text":"An expectation for a measurement, indicating the parameters of and conditions under which to perform the measurement. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"measurement_spec\" name String Required The name of the Spec notes String None Some free-form notes about the Spec tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API template Measurement Template None A template bounding the valid values for parameter and conditions of the measurement. parameters Set[ Parameters ] Empty Specified parameters for the measurement conditions Set[ Conditions ] Empty Specified conditions for the measurement","title":"Measurement Spec"},{"location":"specification/objects/#measurement-run","text":"A particular instance of a measurement. Field name Value type Default Description uids Map[String, String] Empty A collection of Unique Identifiers type String Required \"measurement_run\" name String Required The name of the Measurement Run notes String None Some free-form notes about the Measurement Run tags Set[String] Empty Tags file_links Set[ File Links ] Empty Links to associated files, with resource paths into the files API source Source None provenance information for the measurement spec Measurement Spec Required The Measurement Spec of which this is a run material Material Run Required The Material Run being measured parameters Set[ Parameters ] Empty Measured parameters for the measurement conditions Set[ Conditions ] Empty Measured conditions for the measurement properties Set[ Properties ] Empty Measured properties for the measurement","title":"Measurement Run"},{"location":"specification/objects/#source","text":"Provenance is the documented history of an Object. This includes information such as who performed a measurement, the literature source describing the design of a process, or the purveyor and catalog number for a purchased material. This type of information tends to have limited value for modeling and other analysis but is essential for verification and auditing. At present the only type of source supported is who performed a task and when they did so. Sources can be added to Process Run and Measurement Run Objects only. Field name Value type Default Description type String Required \"performed_source\" performed_by String None The person who performed the measurement performed_date String None The date the measurement was performed; ISO-8601 date-formatted string (YYYY-MM-DD or YYYY-MM-DDTHH:mm:SS)","title":"Source"},{"location":"specification/objects/#common-motifs","text":"","title":"Common Motifs"},{"location":"specification/objects/#multiple-outputs","text":"A process that produces many output Materials should be characterized through individual Process Runs for each output Material, even if the process occurred in the same piece of equipment.","title":"Multiple Outputs"},{"location":"specification/objects/#multiple-mixing-steps","text":"If a mixing process is run multiple times, for example, to incorporate \"a little extra\" of a certain ingredient, each subsequent mixing step should have a unique instance of an \"Additional Mixing\" Process Run and Spec, which, crucially, should point to a Process Template distinct from the initial mixing Process Template.","title":"Multiple Mixing Steps"},{"location":"specification/tags/","text":"Tags \u00b6 For any identifiers that are uniquely associated with an object, we have Alternative ID . However, there are a number of cases where an identifier spans multiple objects. A great example of this would be a Batch ID for multiple outputs of something that is conceptually the same process. Perhaps a user decides that they'd like to bake both a chocolate cake and a vanilla cake in the same oven at the same time. The specified temperatures and durations are similar enough that this should work well. They'd create two Process Runs--one outputting a chocolate cake Material Run, and one outputting a vanilla cake Material Run. But there is nothing recording the fact that both cakes were in the oven together. They can define a tag that would allow them to record this information with the id of their oven, and the date, \"Oven_14::2019-04-15\", and apply that tag to both of the Process Runs and/or Material Runs. Tags \u00b6 Tags are a flexible way to store hierarchical information about your data, or to store identifiers that span many objects. Each tag is string valued, but tags can use :: as a delimiter to define a hierarchy from broad to narrow. However, care should be taken to ensure that the first class in the hierarchy is sufficiently specific such that there is diversity in the first class (or prefix ) of hierarchical tags. This way, the prefix can be used as a partition key for distributing data in a database. Field name Value type Description tags Set[String] A set of strings Constraints \u00b6 Field name Relationship Field Name len( tags ) <= 100 len(a tag) <= 256, UTF-8 encoded Example \u00b6 { \"tags\" : [ \"product_13::batch_45\", \"kiln_37::2019-04-12\", \"Al203::powder::batch_24\", \"fresh powdah\" ] }","title":"Tags"},{"location":"specification/tags/#tags","text":"For any identifiers that are uniquely associated with an object, we have Alternative ID . However, there are a number of cases where an identifier spans multiple objects. A great example of this would be a Batch ID for multiple outputs of something that is conceptually the same process. Perhaps a user decides that they'd like to bake both a chocolate cake and a vanilla cake in the same oven at the same time. The specified temperatures and durations are similar enough that this should work well. They'd create two Process Runs--one outputting a chocolate cake Material Run, and one outputting a vanilla cake Material Run. But there is nothing recording the fact that both cakes were in the oven together. They can define a tag that would allow them to record this information with the id of their oven, and the date, \"Oven_14::2019-04-15\", and apply that tag to both of the Process Runs and/or Material Runs.","title":"Tags"},{"location":"specification/tags/#tags_1","text":"Tags are a flexible way to store hierarchical information about your data, or to store identifiers that span many objects. Each tag is string valued, but tags can use :: as a delimiter to define a hierarchy from broad to narrow. However, care should be taken to ensure that the first class in the hierarchy is sufficiently specific such that there is diversity in the first class (or prefix ) of hierarchical tags. This way, the prefix can be used as a partition key for distributing data in a database. Field name Value type Description tags Set[String] A set of strings","title":"Tags"},{"location":"specification/unique-identifiers/","text":"Unique Identifiers \u00b6 There is a single top-level uids element on all Objects. This element is a map from scope to id with a maximum of 8 total elements. Citrine reserves one scope and will not allow a value to be set: \"ID\". This reserved element is referred to as the Citrine ID, and will always point to a version 4 random UUID generated by the Citrine Platform. The remaining elements of the map are referred to as \"alternative identifiers\" or \"customer identifiers\". The id component of customer identifiers need not be globally unique on its own, but the pair of ( scope , id ) must be unique. Equivalently, every alternative uid must be unique within its designated scope. Each scope , id pair can be associated with exactly one object. Scopes should be interpreted as case-insensitive, e.g., MyId and MYID refer to the same scope. Citrine ID \u00b6 The unique identifier for all Objects on the platform Scope Value type Description ID String string representation of a random Version 4 UUID Constraints \u00b6 Field name Relationship Constraint len( id ) == 36 id parses to Version 4 Random UUID Example \u00b6 { \"uids\" : { \"id\" : \"f36099b9-2ca1-4ff7-afd2-dd226dc79e66\" } } Alternative IDs \u00b6 A scope and identifier that, together, form an alternative unique identifier for an object platform-wide. Field name Value type Description uids Map[String, String] a map from scope to id Constraints \u00b6 Field name Relationship Constraint len( uids ) <= 8 len( scope ) <= 128, UTF-8 encoded len( id ) <= 512, UTF-8 encoded scope cannot include :: Example \u00b6 { \"uids\": { \"NIST-SRM\" : \"141e\" } } Invalid Example \u00b6 This scope field is not allowed by the Citrine Platform: { \"uids\": { \"NIST::SRM\" : \"141e\" } } LinkByUID \u00b6 Any nested object with a unique identifier can be replaced by a LinkByUID object. In general, the SDK for the data model implementation should handle translating nested structures into LinkByUID objects at write time--users of the SDK should only need to specify a LinkByUID object under very specific circumstances. Field name Value type Description type String \"link_by_uid\" scope String The scope of the unique identifier, e.g., \"ID\" for the Citrine ID id String The value of the identifier within that scope, e.g., a UUID4 for the Citrine ID Example \u00b6 { \"type\" : \"link_by_uid\", \"scope\" : \"id\", \"id\" : \"8ee36a2e-66ce-4106-81c9-2b73cc0c6cb9\" } { \"type\" : \"link_by_uid\", \"scope\" : \"NIST-SRM\", \"id\" : \"141e\" }","title":"Unique Identifiers"},{"location":"specification/unique-identifiers/#unique-identifiers","text":"There is a single top-level uids element on all Objects. This element is a map from scope to id with a maximum of 8 total elements. Citrine reserves one scope and will not allow a value to be set: \"ID\". This reserved element is referred to as the Citrine ID, and will always point to a version 4 random UUID generated by the Citrine Platform. The remaining elements of the map are referred to as \"alternative identifiers\" or \"customer identifiers\". The id component of customer identifiers need not be globally unique on its own, but the pair of ( scope , id ) must be unique. Equivalently, every alternative uid must be unique within its designated scope. Each scope , id pair can be associated with exactly one object. Scopes should be interpreted as case-insensitive, e.g., MyId and MYID refer to the same scope.","title":"Unique Identifiers"},{"location":"specification/unique-identifiers/#citrine-id","text":"The unique identifier for all Objects on the platform Scope Value type Description ID String string representation of a random Version 4 UUID","title":"Citrine ID"},{"location":"specification/unique-identifiers/#alternative-ids","text":"A scope and identifier that, together, form an alternative unique identifier for an object platform-wide. Field name Value type Description uids Map[String, String] a map from scope to id","title":"Alternative IDs"},{"location":"specification/unique-identifiers/#linkbyuid","text":"Any nested object with a unique identifier can be replaced by a LinkByUID object. In general, the SDK for the data model implementation should handle translating nested structures into LinkByUID objects at write time--users of the SDK should only need to specify a LinkByUID object under very specific circumstances. Field name Value type Description type String \"link_by_uid\" scope String The scope of the unique identifier, e.g., \"ID\" for the Citrine ID id String The value of the identifier within that scope, e.g., a UUID4 for the Citrine ID","title":"LinkByUID"},{"location":"specification/value-types/","text":"Value Types \u00b6 Value is a generic term for the information contained in an attribute . A Value may be one of the following Value Types: Value Type Variant Description RealValue NominalReal NormalReal UniformReal A double value and a unit (e.g., 32F, 45 meters, 14 kg). Each variation provides a different mechanism for defining uncertainty. IntegerValue NominalInteger UniformInteger A whole integer value. Categorical NominalCategorical DiscreteCategorical Categorical values are distributions over the valid category names representing the probability of each category. For DiscreteCategorical, the values must sum to 1.0. Composition NominalComposition EmpiricalFormula A value containing the composition of the material as a map from the names of the components to their numerical quantities. The quantities are not required to be expressed on a unit or fractional basis. Molecular Smiles Inchi Molecular structure using popular encoding schemes. Many of these values represent probability distributions, such as normal and uniform distributions over continuous bounds or discrete distributions over categorical ones. Each of the Value Types is described below. Every field is required. Real Values \u00b6 Two common distributions are supported: normal (i.e., Gaussian) and uniform. In cases when there is no distributional information, the \"nominal\" value type can be used to specify the expected value. Normal Real Value \u00b6 Normally distributed value parameterized by a real-valued mean and standard deviation. A normal distribution is considered valid with a set of Real Bounds if the mean lies between the upper and lower bound; the width of the distribution is not considered. From a computational perspective, this means Normal Real Values are actually truncated Gaussians, though this is only significant for a distribution near the boundary. Field name Value type Description type String \"normal_real\" mean Number Mean of the distribution std Number Standard deviation of the normal distribution units String A String describing the units Constraints \u00b6 Field name Relationship Field Name std >= 0 Example \u00b6 { \"type\" : \"normal_real\", \"units\" : \"kelvin\", \"mean\": 350, \"std\": 1.03 } Uniform Real Value \u00b6 A Uniform continuous distribution value, with inclusive lower and upper bounds. These are especially useful for expressing uncertainty when the number of digits is truncated. In order to be valid, the entirety of the distribution must fall within the bounds. Field name Value type Description type String \"uniform_real\" lower_bound Number Lower bound of the distribution upper_bound Number Upper bound of the distribution units String A String describing the units ##### Constraints Field name Relationship Field Name lower_bound <= upper_bound Example \u00b6 A value field read off a digital display with 3 decimal points. { \"type\" : \"uniform_real\", \"units\" : \"meter\", \"lower_bound\": 0.9995, \"upper_bound\": 1.0005 } Nominal Real Value \u00b6 Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_real\" nominal Number A nominal value - not assumed to be exact units String A String describing the units Constraints \u00b6 None Example \u00b6 { \"type\" : \"nominal_real\", \"units\" : \"meter\", \"nominal\": 1.0 } Integer Values \u00b6 Currently, there are two integer types: a uniform (i.e., range) distribution and a nominal (i.e., specified) value. Uniform Integer Value \u00b6 A uniform integer distribution value, with inclusive lower and upper bounds. These are especially useful for expressing uncertainty when the number of digits is truncated. In order to be valid, the entirety of the distribution must fall within the bounds. Field name Value type Description type String \"uniform_integer\" lower_bound Integer Lower bound of the distribution upper_bound Integer Upper bound of the distribution Constraints \u00b6 Field name Relationship Field Name lower_bound <= upper_bound Example \u00b6 A value field recorded from a digital display recording an approximate number of counts (e.g., Geiger counter reading \"250\"). { \"type\" : \"uniform_integer\", \"lower_bound\": 245, \"upper_bound\": 254 } Nominal Integer Value \u00b6 Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_integer\" nominal Integer A nominal value - not assumed to be exact Constraints \u00b6 None Example \u00b6 { \"type\" : \"nominal_integer\", \"nominal\": 42 } Categorical \u00b6 Categorical values are distributions over the valid category names representing the probability of each category. These are different than mixtures; 60% water and 40% ethanol is not a categorical distribution. For those, see Composition . Currently, there are two categorical types: a discrete (i.e., enumerated) distribution and a nominal (i.e., specified) value. Discrete Categorical Value \u00b6 Discrete categorical values represent a distribution of categories stored as a map from the string label to the probability. Field name Value type Description type String \"discrete_categorical\" probabilities Map[String, Number] A map from string category names to their probability. Constraints \u00b6 Field name Relationship Field Name abs(sum(probabilities.values()) - 1.0) < 1.0e-9 each probability value >= 0 In other words, a probability cannot be negative and the probabilities sum to one. Example \u00b6 { \"type\":\"discrete_categorical\", \"probabilities\" : { \"red\" : 0.54, \"blue\" : 0.46 } } Nominal Categorical Value \u00b6 Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_categorical\" category String The category of the value Constraints \u00b6 None Example \u00b6 { \"type\" : \"nominal_categorical\", \"category\" : \"red\" } Composition \u00b6 A value representing the composition of the material as a set of component names and their respective quantities. The quantities are not required to be expressed on a unit or fractional basis. For example, \"one part flour two parts sugar\" is acceptable. Nominal Composition \u00b6 A composition represented as a map from the component name to the quantity. The quantities do not express an uncertainty, but also do not imply that there is absolute certainty in their values. Field name Value type Description type String \"nominal_composition\" quantities Map[String, Number] Map[String, Number] Constraints \u00b6 Field name Relationship Field Name each quantity value >= 0 Example \u00b6 { \"type\" : \"nominal_composition\", \"quantities\" : { \"water\" : 120, \"ethanol\" : 80 } } Empirical Formula \u00b6 A composition represented as a chemical formula string. The order and grouping of the elements is ignored. Field name Value type Description type String \"empirical_formula\" formula String Chemical formula to be parsed as an empirical formula Example \u00b6 { \"type\" : \"empirical_formula\", \"formula\" : \"SiO2\" } Molecular Structure \u00b6 Molecular structure types are used to define attributes that contain information about the structure and composition of a molecule. Given a molecular structure, one can infer the chemical formula, existence of functional groups, and local chemical environment of each atom in the molecule. Most commonly a molecular structure will refer to the entire material, but multiple molecular structures can be used to define fragments of a material, e.g., monomers of a polymer. There are two ways to represent a molecular structure: SMILES string InChI string SMILES Value \u00b6 A value containing a SMILES string . Field name Value type Description type String \"smiles\" smiles String A SMILES string Example \u00b6 { \"type\" : \"smiles\", \"smiles\" : \"c1(C=O)cc(OC)c(O)cc1\" } InChI Value \u00b6 A value containing an InChI string . Note: this is not the same as the InChI key. Field name Value type Description type String \"inchi\" inchi String An InChI string Example \u00b6 { \"type\" : \"inchi\", \"inchi\" : \"InChI=1/C8H8O3/c1-11-8-4-6(5-9)2-3-7(8)10/h2-5,10H,1H3\" }","title":"Value Types"},{"location":"specification/value-types/#value-types","text":"Value is a generic term for the information contained in an attribute . A Value may be one of the following Value Types: Value Type Variant Description RealValue NominalReal NormalReal UniformReal A double value and a unit (e.g., 32F, 45 meters, 14 kg). Each variation provides a different mechanism for defining uncertainty. IntegerValue NominalInteger UniformInteger A whole integer value. Categorical NominalCategorical DiscreteCategorical Categorical values are distributions over the valid category names representing the probability of each category. For DiscreteCategorical, the values must sum to 1.0. Composition NominalComposition EmpiricalFormula A value containing the composition of the material as a map from the names of the components to their numerical quantities. The quantities are not required to be expressed on a unit or fractional basis. Molecular Smiles Inchi Molecular structure using popular encoding schemes. Many of these values represent probability distributions, such as normal and uniform distributions over continuous bounds or discrete distributions over categorical ones. Each of the Value Types is described below. Every field is required.","title":"Value Types"},{"location":"specification/value-types/#real-values","text":"Two common distributions are supported: normal (i.e., Gaussian) and uniform. In cases when there is no distributional information, the \"nominal\" value type can be used to specify the expected value.","title":"Real Values"},{"location":"specification/value-types/#normal-real-value","text":"Normally distributed value parameterized by a real-valued mean and standard deviation. A normal distribution is considered valid with a set of Real Bounds if the mean lies between the upper and lower bound; the width of the distribution is not considered. From a computational perspective, this means Normal Real Values are actually truncated Gaussians, though this is only significant for a distribution near the boundary. Field name Value type Description type String \"normal_real\" mean Number Mean of the distribution std Number Standard deviation of the normal distribution units String A String describing the units","title":"Normal Real Value"},{"location":"specification/value-types/#uniform-real-value","text":"A Uniform continuous distribution value, with inclusive lower and upper bounds. These are especially useful for expressing uncertainty when the number of digits is truncated. In order to be valid, the entirety of the distribution must fall within the bounds. Field name Value type Description type String \"uniform_real\" lower_bound Number Lower bound of the distribution upper_bound Number Upper bound of the distribution units String A String describing the units ##### Constraints Field name Relationship Field Name lower_bound <= upper_bound","title":"Uniform Real Value"},{"location":"specification/value-types/#nominal-real-value","text":"Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_real\" nominal Number A nominal value - not assumed to be exact units String A String describing the units","title":"Nominal Real Value"},{"location":"specification/value-types/#integer-values","text":"Currently, there are two integer types: a uniform (i.e., range) distribution and a nominal (i.e., specified) value.","title":"Integer Values"},{"location":"specification/value-types/#uniform-integer-value","text":"A uniform integer distribution value, with inclusive lower and upper bounds. These are especially useful for expressing uncertainty when the number of digits is truncated. In order to be valid, the entirety of the distribution must fall within the bounds. Field name Value type Description type String \"uniform_integer\" lower_bound Integer Lower bound of the distribution upper_bound Integer Upper bound of the distribution","title":"Uniform Integer Value"},{"location":"specification/value-types/#nominal-integer-value","text":"Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_integer\" nominal Integer A nominal value - not assumed to be exact","title":"Nominal Integer Value"},{"location":"specification/value-types/#categorical","text":"Categorical values are distributions over the valid category names representing the probability of each category. These are different than mixtures; 60% water and 40% ethanol is not a categorical distribution. For those, see Composition . Currently, there are two categorical types: a discrete (i.e., enumerated) distribution and a nominal (i.e., specified) value.","title":"Categorical"},{"location":"specification/value-types/#discrete-categorical-value","text":"Discrete categorical values represent a distribution of categories stored as a map from the string label to the probability. Field name Value type Description type String \"discrete_categorical\" probabilities Map[String, Number] A map from string category names to their probability.","title":"Discrete Categorical Value"},{"location":"specification/value-types/#nominal-categorical-value","text":"Nominal value, which does not specify an uncertainty but is not to be assumed to be exact. Field name Value type Description type String \"nominal_categorical\" category String The category of the value","title":"Nominal Categorical Value"},{"location":"specification/value-types/#composition","text":"A value representing the composition of the material as a set of component names and their respective quantities. The quantities are not required to be expressed on a unit or fractional basis. For example, \"one part flour two parts sugar\" is acceptable.","title":"Composition"},{"location":"specification/value-types/#nominal-composition","text":"A composition represented as a map from the component name to the quantity. The quantities do not express an uncertainty, but also do not imply that there is absolute certainty in their values. Field name Value type Description type String \"nominal_composition\" quantities Map[String, Number] Map[String, Number]","title":"Nominal Composition"},{"location":"specification/value-types/#empirical-formula","text":"A composition represented as a chemical formula string. The order and grouping of the elements is ignored. Field name Value type Description type String \"empirical_formula\" formula String Chemical formula to be parsed as an empirical formula","title":"Empirical Formula"},{"location":"specification/value-types/#molecular-structure","text":"Molecular structure types are used to define attributes that contain information about the structure and composition of a molecule. Given a molecular structure, one can infer the chemical formula, existence of functional groups, and local chemical environment of each atom in the molecule. Most commonly a molecular structure will refer to the entire material, but multiple molecular structures can be used to define fragments of a material, e.g., monomers of a polymer. There are two ways to represent a molecular structure: SMILES string InChI string","title":"Molecular Structure"},{"location":"specification/value-types/#smiles-value","text":"A value containing a SMILES string . Field name Value type Description type String \"smiles\" smiles String A SMILES string","title":"SMILES Value"},{"location":"specification/value-types/#inchi-value","text":"A value containing an InChI string . Note: this is not the same as the InChI key. Field name Value type Description type String \"inchi\" inchi String An InChI string","title":"InChI Value"}]}